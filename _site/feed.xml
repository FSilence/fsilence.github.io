<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-05-23T06:44:41+00:00</updated><id>http://localhost:4000/</id><title type="html">FSilence’s Blog</title><subtitle>FSilence的个人博客</subtitle><author><name>FSilence</name></author><entry><title type="html">Mac Shell的配置</title><link href="http://localhost:4000/2017/05/23/mac-shell-config/" rel="alternate" type="text/html" title="Mac Shell的配置" /><published>2017-05-23T00:00:00+00:00</published><updated>2017-05-23T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/23/mac-shell-config</id><content type="html" xml:base="http://localhost:4000/2017/05/23/mac-shell-config/">&lt;p&gt;要想方便的使用mac，shell的使用个人认为是必不可少的，在我们拿到mac的时候，我们应该先配置好我们的shell，这样可以极大的提高我们的效率。本文不会描述具体的配置过程，只是对相关配置资料的一个索引。&lt;/p&gt;

&lt;h2 id=&quot;zsh&quot;&gt;zsh&lt;/h2&gt;
&lt;p&gt;为什么我要使用zsh 而不是bash，可以参照&lt;a href=&quot;https://www.zhihu.com/question/21418449&quot;&gt;为什么说 zsh 是 shell 中的极品？
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mac安装zsh: &lt;br /&gt;
zsh的配置能力非常强，如果你要自己完全配置zsh你会发现非常非常复杂，还好有人给我我们提供了不错的配置方案 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;on-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;配置zsh:&lt;br /&gt;
zsh的配置在文件 ~/.zshrc中，我们可以在其中使用别名，配置插件等提高shell的使用效率。&lt;br /&gt;
zsh的具体配置可以参照&lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/24a0ded2e3ba&quot;&gt;在osx中配置和使用zsh&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/ii1245712564/article/details/45843657&quot;&gt; zsh安装和配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Terminal自动开启zsh:&lt;br /&gt;
安装好on-my-zsh后，我们可以在 ~/.bash_profile中 添加一行 zsh，这样每次启动terminal的时候就都是zsh&lt;/p&gt;

&lt;h2 id=&quot;安装autojump&quot;&gt;安装autojump&lt;/h2&gt;
&lt;p&gt;通过 brew 安装autojump:&lt;/p&gt;
&lt;pre&gt;
brew install autojump
&lt;/pre&gt;

&lt;p&gt;在 ~/.zshrc中加入以下内容&lt;/p&gt;
&lt;pre&gt;
[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . ~/.autojump/etc/profile.d/autojump.sh
&lt;/pre&gt;

&lt;p&gt;然后重新启动zsh，就可以通过j + 目录名跳转到任何你cd过的目录中，支持模糊匹配。&lt;/p&gt;

&lt;h2 id=&quot;配置vi&quot;&gt;配置vi&lt;/h2&gt;
&lt;p&gt;vi的插件管理 参考 &lt;a href=&quot;http://blog.csdn.net/zhangpower1993/article/details/52184581&quot;&gt;VBundle的介绍及安装&lt;/a&gt;&lt;br /&gt;
vi的插件统建 参考 &lt;a href=&quot;http://blog.csdn.net/namecyf/article/details/7787479&quot;&gt;vi配置及插件管理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://fsilence.com/wiki/mac-bash/&quot;&gt;osx shell快捷键&lt;/a&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">要想方便的使用mac，shell的使用个人认为是必不可少的，在我们拿到mac的时候，我们应该先配置好我们的shell，这样可以极大的提高我们的效率。本文不会描述具体的配置过程，只是对相关配置资料的一个索引。</summary></entry><entry><title type="html">window的showAsDropDown失效的问题</title><link href="http://localhost:4000/2017/05/17/popupwindow-showAsDropDown/" rel="alternate" type="text/html" title="window的showAsDropDown失效的问题" /><published>2017-05-17T00:00:00+00:00</published><updated>2017-05-17T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/17/popupwindow-showAsDropDown</id><content type="html" xml:base="http://localhost:4000/2017/05/17/popupwindow-showAsDropDown/">&lt;p&gt;在使用Popupwindow的showAsDropDown的时候，有时候会在特定机型上无法正确显示（全屏显示了）。&lt;/p&gt;

&lt;p&gt;目前的解决方案是如果需要全屏显示的popwindow，要计算出window的实际高度然后调用popupwindow的setHeight方法后再调用showAdDropDown即可。&lt;br /&gt;
获取PopupWindow的实际高度:&lt;/p&gt;
&lt;pre&gt;
    public static void showPopwindow(Context context, PopupWindow popupWindow, View anchor) {
        int[] locations = new int[2];
        anchor.getLocationOnScreen(locations);
        int screenHeight = context.getApplicationContext().getResources().getDisplayMetrics(); 
	int height = screenHeight - anchor.getHeight() - locations[1];
        popupWindow.setHeight(height);
        popupWindow.showAsDropDown(anchor);
    }
&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">在使用Popupwindow的showAsDropDown的时候，有时候会在特定机型上无法正确显示（全屏显示了）。</summary></entry><entry><title type="html">multidex找不到的问题</title><link href="http://localhost:4000/2017/05/17/as-multidex-notfound/" rel="alternate" type="text/html" title="multidex找不到的问题" /><published>2017-05-17T00:00:00+00:00</published><updated>2017-05-17T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/17/as-multidex-notfound</id><content type="html" xml:base="http://localhost:4000/2017/05/17/as-multidex-notfound/">&lt;p&gt;最近将AndroidStudio升级到了2.3， 然后发现instan run不好使了，要求Gradle插件版本必须是2.3以上，所以讲gradle插件版本修改为2.3.1，然后发现点击运行会报错：程序包：multidex 找不到。&lt;/p&gt;

&lt;p&gt;在之前的版本中只要配置好multidex = true 插件会自动引用multidex的包，升级到2.3.1后不能自动引用 只能手动添加了, 在dependencies中添加：&lt;br /&gt;
 compile “com.android.support:multidex:1.0.1” 即可。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">最近将AndroidStudio升级到了2.3， 然后发现instan run不好使了，要求Gradle插件版本必须是2.3以上，所以讲gradle插件版本修改为2.3.1，然后发现点击运行会报错：程序包：multidex 找不到。</summary></entry><entry><title type="html">IPC之Messenger</title><link href="http://localhost:4000/2017/05/16/ipc-messenger/" rel="alternate" type="text/html" title="IPC之Messenger" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/ipc-messenger</id><content type="html" xml:base="http://localhost:4000/2017/05/16/ipc-messenger/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.学会使用Messenger进行进程间通信
&lt;/pre&gt;

&lt;p&gt;在进行具体的探讨之前，我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。&lt;/p&gt;

&lt;p&gt;Messenger可以理解为信使，它可以实现消息的发送，底层使用Binder实现的（所以可以跨进程）。我们来看Messenger的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   public Messenger(IBinder target) {
        mTarget = IMessenger.Stub.asInterface(target);
    }

   public Messenger(Handler target) {
        mTarget = target.getIMessenger();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Messenger的构造函数主要有2个 一个 接受一个IBinder参数 一个接受一个Handler参数，我们可以看到它们参数的名称都是叫target，从字面上我们也不难理解，这个参数的作用就是定义消息发送的目标。我们看下Handler中MessengerImpl的具体实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    private final class MessengerImpl extends IMessenger.Stub {
        public void send(Message msg) {
            msg.sendingUid = Binder.getCallingUid();
            Handler.this.sendMessage(msg);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到在发送消息的时候，给msg添加了一个属性，CallingUid,这个CallingUid又是什么呢，我们来看一下Binder中的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  /**
     * Return the Linux uid assigned to the process that sent you the
     * current transaction that is being processed.  This uid can be used with
     * higher-level system services to determine its identity and check
     * permissions.  If the current thread is not currently executing an
     * incoming transaction, then its own uid is returned.
     */
    public static final native int getCallingUid();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难发现这个UId其实就是调用方进程的UID(用户身份的标识符)。
那么这个IMessenger.Stub是什么呢？这里我们不加讨论，在AIDL的实现中我们会重点讨论这个。&lt;br /&gt;
我们接着再来看下如何用Messenger实现IPC，我们先看下客户端的实现:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在onServiceConnected中用返回的IBinder new一个Messenger（消息的发送者），然后创建Message直接send即可，那么服务端又是如何接收处理这个消息的呢：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class MessengerService extends Service{
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };
    Messenger messenger = new Messenger(handler);
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return messenger.getBinder();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端的实现也很简单 定义一个Handler 和 Messenger（消息的接收者，交给Handler处理） 然后返回messenger的getBinder即可。这样我们就实现了进程的单向通信，那么如何实现双向通信呢，其实也很简单我们只要给message添加一个replyTo的对象（也是一个Messenger）然后使用这个replyTo就可以进行消息的应答。其实我们可以思考一下如果我们需要实现双向沟通是不是需要一个发送者来发送消息， 一个接收者来接受消息。我们来一下基于上面单向通信的改进，首先来看客户端的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  	Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;reply info : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };

    Messenger receiveMessenger = new Messenger(handler);

     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
				message.replyTo = receiveMessenger;
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现在单向通信的基础上我们添加了一个接收者 receiverMessenter, 然后将其赋值给msg的replyTo， 服务端就可以取到这个Messenger来进行消息回复。&lt;br /&gt;
我们再来看下服务端的改进：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
            Message replyMsg = new Message();
            Bundle data = new Bundle();
            data.putString(&quot;info&quot;, &quot; this is from server&quot;);
            replyMsg.setData(data);
            try {
                msg.replyTo.send(replyMsg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要通过msg.replyTo来发送消息回复就可以了，是不是很简单。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.学会使用Messenger进行进程间通信</summary></entry><entry><title type="html">EventBus Q&amp;amp;A</title><link href="http://localhost:4000/2017/05/16/eventbus-qa/" rel="alternate" type="text/html" title="EventBus Q&amp;A" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/eventbus-qa</id><content type="html" xml:base="http://localhost:4000/2017/05/16/eventbus-qa/">&lt;p&gt;阅读EventBus源码过程中总结的一些问题和答案&lt;/p&gt;

&lt;h3 id=&quot;eventbus-中如果一个subscriber中的父类也注册了相同的监听事件以哪个为准&quot;&gt;EventBus 中如果一个subscriber中的父类也注册了相同的监听事件，以哪个为准&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;以子类中的事件为准，在SubscriberMethodFinder方法中，在添加一个subscribeMethod的时候  会调用FindState的checkAdd方法，其中有这么一段逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                // Only add if not already found in a sub class
                return true;
            } else {
                // Revert the put, old class is further down the class hierarchy
                subscriberClassByMethodKey.put(methodKey, methodClassOld);
                return false;
            }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果原先注册过的methodClass 是当前想要注册的methodClass的父类的话，返回true，（isAssignableFrom 判断类是否是另一个类的父类）
在结束后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 if (findState.checkAdd(method, eventType)) {
ThreadMode threadMode = subscribeAnnotation.threadMode();
findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果checkAdd返回了true的话 表示可以添加当前method到列表中&lt;/p&gt;

&lt;p&gt;###SubscribeMethodFinder中的FindStat有什么用
FindStat用来记录一次查找的中间变量和结果，其中的superClass用来帮助查找器进行递归查找。&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的event-对象是如何管理的&quot;&gt;EventBus中的event 对象是如何管理的&lt;/h3&gt;
&lt;p&gt;当用户通过post来发送一个消息的时候，EventBus会首先获取一个PostThreadStat对象（通过ThreadLocal存放的 每个线程都会有一份，来记录当前线程的一些发送状态），然后将消息放入到PostThreadStat中的event队列，然后会依次取队列中的消息，进行发送操作。&lt;br /&gt;
单次的发送操作： 
如果eventInheritance为true(默认为true)，就先查找出所有的父类 和 接口，都记录为event，发送，如果为false 则只发送当前消息。如果没有找到对应的订阅者，则抛出一个NoSubscriberEvent的消息。如果有订阅者，则根据订阅者的类型来选择发送的方式。&lt;br /&gt;
EventBus中有3个变量来保存消息，1.subscriptionsByEventType 一个Map,key是eventType value是subscribtions，主要用来post消息的时候可以找到对应的subscribtion来换起方法。2.typesBySubscriber 一个Map,key是订阅者 value是订阅的事件列表，主要用来在unregister订阅者的时候方便去清空对应的数据。3.stickyEvents 主要是用来存放sticky消息的。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的register的过程&quot;&gt;EventBus的register的过程&lt;/h3&gt;
&lt;p&gt;register一个订阅者的时候，会进行以下几步：&lt;br /&gt;
1.通过subscriberMethodFinder查找到所有注释的订阅方法&lt;br /&gt;
2.循环依次注册方法&lt;br /&gt;
3.每一次注册的时候，根据优先级加入到列表中（subscriptionsByEventType的value），优先级高的在前面&lt;br /&gt;
4.更新typesBySubscriber&lt;br /&gt;
5.如果注册的方法是sticky的，则检查当前的stickyEvents列表，触发sticky消息的相应&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder的查找过程&quot;&gt;SubscriberMethodFinder的查找过程&lt;/h3&gt;
&lt;p&gt;Finder中每次查找结果都有缓存（不会有泄露 因为缓存的应用都是Class Method这些）,可以通过EventBus的clearCache来清空。（我们可以考虑在onLowMemory的时候调用此方法）
SubscirberMethodFinder中有一个FindStat类用来帮助记录一次查找的中间状态和结果 以及帮助递归查找（里面有一个superClass的参数），每次遍历类和父类找到注册方法。&lt;br /&gt;
FindStat中有一个checkAdd方法 来判断当前方法是否应该添加到subscribMethod中。在checkAdd方法中，会根据当前类是否注册过来判断是否可以添加。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的poststicky-和-post消息有什么区别&quot;&gt;EventBus的postSticky 和 post消息有什么区别&lt;/h3&gt;
&lt;p&gt;post过程见上。&lt;br /&gt;
postSticky 先将消息放入到stickyEvents的map中 然后再调用post消息&lt;/p&gt;

&lt;h3 id=&quot;eventbus的threadmode类型&quot;&gt;EventBus的threadMode类型&lt;/h3&gt;
&lt;p&gt;POSTING:在发送事件的线程中通知订阅者&lt;br /&gt;
MAIN:如果当前是主线程直接通知订阅者，否则调用HandlePoster的enque方法在主线程中通知订阅者&lt;br /&gt;
BACKGROUD:如果当前不是主线程中则直接通知订阅者，否则启动一个后台线程来通知订阅者（不同的消息共用一个线程）&lt;br /&gt;
ASYN:启动不同的线程来通知订阅者&lt;/p&gt;

&lt;p&gt;HandlerPoster:帮助主线程中的调度，其中维护一个PendingPost的队列，在handleMessage中依次弹出消息并通知。&lt;/p&gt;

&lt;p&gt;BackgroundPoster:帮助实现BACKGROUND模式，BackgroundPoster本身是一个runable，通过enque一个event对象，如果当前有线程正在处理post消息则直接在此线程中处理，否则会通过eventBus调用
builder中设置的线程池来执行线程（在run方法中循环取出消息队列中的消息来处理）&lt;/p&gt;

&lt;p&gt;AsyncPoster：帮助实现ASYN模式，本事是一个Runnable,enque一个event对象后会直接换起线程池来执行线程，在run中poll一个消息来处理&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的eventtypescache是干什么用的&quot;&gt;EventBus中的eventTypesCache是干什么用的&lt;/h3&gt;
&lt;p&gt;在eventInheritance为true的时候 会通过发送的event对象 查找event对象的所有父类和接口，这个cache就是用来缓存这个的。&lt;br /&gt;
通过clearCaches来清空缓存&lt;/p&gt;

&lt;h3 id=&quot;如何理解pendingpost&quot;&gt;如何理解PendingPost&lt;/h3&gt;
&lt;p&gt;PendingPost是一次post的意图，其中定义了要发送的事件event 和 订阅方法 以及next 意图（用来和pendingPostQueue配合 实现队列）&lt;/p&gt;

&lt;h3 id=&quot;eventbus中用到了哪些设计模式&quot;&gt;EventBus中用到了哪些设计模式&lt;/h3&gt;
&lt;p&gt;创建者模式： Builder&lt;br /&gt;
订阅者模式： 整体就是订阅模式&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder中的findstat是如何确定一个方法是否应该被记录的&quot;&gt;*SubscriberMethodFinder中的FindStat是如何确定一个方法是否应该被记录的&lt;/h3&gt;
&lt;p&gt;（重点是FindStat中的2个临时变量 之后再做补充说明）&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">阅读EventBus源码过程中总结的一些问题和答案</summary></entry><entry><title type="html">IPC之AIDL(3)系统为我们做了什么</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/" rel="alternate" type="text/html" title="IPC之AIDL(3)系统为我们做了什么" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-3</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.了解基本的aidl原理（不涉及底层）
&lt;/pre&gt;

&lt;p&gt;前面几篇我们介绍了如何使用AIDL实现IPC 那么你会有疑问了 我们用的asInterface是什么， Stub又是什么，现在让我们一点一点来看。在我们编译的时候，系统会吧aidl生成对应的java类（这就是为什么支持aidl这种文件格式了），我们先来看一下系统生成的类(本文涉及到的系统源码都是基于android-23)：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
package com.wlh.animation.ipctest;
// Declare any non-default types here with import statements

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.wlh.animation.ipctest.IBookManager {
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.wlh.animation.ipctest.IBookManager interface,
         * generating a proxy if needed.
         */
        public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
    		...
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                   ...
                }
                case TRANSACTION_getBookList: {
                   ...
                }
                case TRANSACTION_addBook: {
                  ...
                }
                case TRANSACTION_registerListener: {
                   ...
                }
                case TRANSACTION_unRegisterListener: {
                   ...
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.wlh.animation.ipctest.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException {
       			...
            }

            @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
     			...
            }

            @Override
            public void registerListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
               		...
            }

            @Override
            public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
          		...
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    }

    public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException;

    public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException;

    public void registerListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;

    public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;
}
&amp;lt;/pre&amp;gt;
&amp;lt;/code&amp;gt;

我们先忽略方法的具体实现，来看一下这个系统为我们生成的类中都有哪些东西：  
1.整个文件是一个IBookManager(你aidl文件名字)的接口 继承IInterface  
2.一个抽象类Stub继承Binder（前面我们说过  Binder有跨进程的能力）实现了这个IBookManager接口  
3.一个代理类实现了IBookManager(注意没有继承Binder)  
然后我们依次来解析一下这写类：  
##IBookManager IInterface 
首先是IBookManager,它是一个继承自IInterface的接口，我们先来看下IInterface接口中有哪些东西：  
&lt;pre&gt;
&lt;code&gt;
public interface IInterface
{
    public IBinder asBinder();
}
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到IInterface中只有一个方法 就是asBinder 返回一个IBinder,IBinder也是一个接口。

##Stub Binder
Stub是一个抽象类继承了Binder 实现了IBookManager接口

###Binder
Binder实现了IBinder，我们来看下IBinder中的内容.我们这里只介绍一些重要的变量和方法，其它的说明读者可自行查阅源码中的注释。  
###getInterfaceDescriptor
源码定义如下：  
&lt;pre&gt;
&lt;code&gt;
  /**
     * Get the canonical name of the interface supported by this binder.
     */
    public String getInterfaceDescriptor() throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个返回接口的名称，我们在Binder中可以看到它的具体实现：  
&lt;pre&gt;
&lt;code&gt;
   public void attachInterface(IInterface owner, String descriptor) {
        mOwner = owner;
        mDescriptor = descriptor;
    }

      public String getInterfaceDescriptor() {
        return mDescriptor;
    }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到系统通过attachInterface来给接口名称赋值，主要是为了作为跨进程通信时候接口的标识，我们可以在Binder的子类Stub也就是系统为我们生成的类中看到具体的接口名称：  
&lt;pre&gt;
&lt;code&gt;
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到其实就是接口的全路径。  

###pingBinder, isBinderAlive, 
&lt;pre&gt;
&lt;code&gt;
  /**
     * Check to see if the object still exists.
     * 
     * @return Returns false if the
     * hosting process is gone, otherwise the result (always by default
     * true) returned by the pingBinder() implementation on the other
     * side.
     */
    public boolean pingBinder();
&lt;/code&gt;
&lt;/pre&gt;
就是字面意思ping一下 来确认Binder是否可以链接到Binder，只有当宿主进程不存在的时候才返回false。  

&lt;pre&gt;
&lt;code&gt;
   /**
     * Check to see if the process that the binder is in is still alive.
     *
     * @return false if the process is not alive.  Note that if it returns
     * true, the process may have died while the call is returning.
     */
    public boolean isBinderAlive();
&lt;/code&gt;
&lt;/pre&gt;
返回Binder是否存活。如果进程不是存活状态，那么返回false。  


###queryLocalInterface

&lt;pre&gt;
&lt;code&gt;
 /**
     * Attempt to retrieve a local implementation of an interface
     * for this Binder object.  If null is returned, you will need
     * to instantiate a proxy class to marshall calls through
     * the transact() method.
     */
    public IInterface queryLocalInterface(String descriptor);
&lt;/code&gt;
&lt;/pre&gt;
根据接口的描述返回一个本地接口，如果返回的是null的话（就是跨进程），需要你去实现代理（在使用aidl的时候系统为我们已经实现好了）  


###transact
&lt;pre&gt;
&lt;code&gt;
/**
     * Perform a generic operation with the object.
     * 
     * @param code The action to perform.  This should
     * be a number between {@link #FIRST_CALL_TRANSACTION} and
     * {@link #LAST_CALL_TRANSACTION}.
     * @param data Marshalled data to send to the target.  Must not be null.
     * If you are not sending any data, you must create an empty Parcel
     * that is given here.
     * @param reply Marshalled data to be received from the target.  May be
     * null if you are not interested in the return value.
     * @param flags Additional operation flags.  Either 0 for a normal
     * RPC, or {@link #FLAG_ONEWAY} for a one-way RPC.
     */
    public boolean transact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个基本上是IBinder中最重要的一个函数了，它用来相应对象的操作，例如我们本例中的一个addBook操作，它的参数主要有如下几个：  
1.code 一次操作的唯一标识，要介于常量FIRST_CALL_TRANSACTION（ 0x00000001）和 LAST_CALL_TRANSACTION（0x00ffffff）之间  

2.data 需要传递的数据不能为空   

3.reply 返回的数据  

4.flats 附加的操作标识，通常返回0. 如果设置成FLAG_ONEWAY表示呼叫方不会等待被呼叫方放回结果（只在跨进程的时候生效）。  


我们再来看下Stub中的具体实现：  

###asInterface
&lt;pre&gt;
&lt;code&gt;
     public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;amp;&amp;amp; (iin instanceof com.wlh.animation.ipctest.IBookManager))) {
                return ((com.wlh.animation.ipctest.IBookManager) iin);
            }
            return new com.wlh.animation.ipctest.IBookManager.Stub.Proxy(obj);
        }
&lt;/code&gt;
&lt;/pre&gt;
将IBinder转换成我们需要的接口，我们可以看到基本的逻辑是：如果从本地找到了接口就返回本地接口（没有跨进程），否则返回Stub的代理类，关于代理类我们稍后再说，这个逻辑规则基本贯穿了Stub中的所有方法：即先找本地，如果没有（跨进程）则返回代理。  

###onTransact
&lt;pre&gt;
&lt;code&gt;
 @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {


   switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_addBook: {
                   。。。
                }
}
}
&lt;/code&gt;
&lt;/pre&gt;
首先在Stub类中 系统为我们的每一个方法值都赋予了一个id
&lt;pre&gt;
    static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
&lt;/pre&gt;
可以看到是基于TRANSACTIOn_{$method name}来命名的参数是基于FIRST_CALL_TRANSACTION递增的。然后再onTransaction方法中系统会switch code判断当前调用的是哪个方法然后做相应的操作 我们来看下addBook的具体实现：  
&lt;pre&gt;
&lt;code&gt;
  case TRANSACTION_addBook: {
    data.enforceInterface(DESCRIPTOR);
                    com.wlh.animation.ipctest.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.wlh.animation.ipctest.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBook(_arg0);
                    reply.writeNoException();
                    if ((_arg0 != null)) {
                        reply.writeInt(1);
                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
	}
&lt;/code&gt;
&lt;/pre&gt;  
我们不难看出，基本思路就是将对象和Parceable之间转换处理。  

我们再来看下代理类Proxy:  
Proxy是实现了接口IBookManager的代理类，其构造方法如下：  
&lt;pre&gt;
&lt;code&gt;
  Proxy(android.os.IBinder remote) {
                mRemote = remote;
   }
&lt;/code&gt;
&lt;/pre&gt;

构造函数是一个IBinder,之后代理中的相关调用都会转到这个Binder中去处理，我们还是来看一下addBookManager接口：  
&lt;pre&gt;
&lt;code&gt;
     @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
                    _reply.readException();
                    if ((0 != _reply.readInt())) {
                        book.readFromParcel(_reply);
                    }
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
&lt;/code&gt;
&lt;/pre&gt;

可以看到和onTransact中最大的区别在于 它将具体的处理时间交给了跨进程的Binder处理。  

以上就是在我们编写AIDL文件后 系统为我们生成文件的解析。




&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.了解基本的aidl原理（不涉及底层）</summary></entry><entry><title type="html">IPC之AIDL(2)in out inout</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-2/" rel="alternate" type="text/html" title="IPC之AIDL(2)in out inout" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-2</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-2/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.在AIDL的时候正确使用in out inout
&lt;/pre&gt;

&lt;p&gt;上一篇我们用AIDL简单实现了一个IPC，其中我们谈到在定义aidl接口中的除基本类型和AIDL接口外的参数要调价修饰符in out 或 inout中的一种，本文将帮助大家理解in out inout，并让读者可以正确的使用in out inout。&lt;br /&gt;
在介绍in out inout的区别之前我们先明确两个基本概念：起点 和 终点，起点指调用方，终点指响应方，比如我在客户端调用aidl接口那么客户端就是起点 服务端就是重点，在一次调用中服务端如果要调用一个aidl接口回调给客户端，那么服务端就是起点，客户端就是重点。&lt;br /&gt;
然后我们来定义in out inout:&lt;br /&gt;
in ： 将对象从起点传递给终点，在终点部分中对对象的修改不会反映到起点，即只输入&lt;br /&gt;
out : 对象中的值不会传递给终点，但是在终点部分对对象的修改会反映到起点，即只输出&lt;br /&gt;
intout : 将对象从起点传递给终点，在终点部分的修改会反应到起点，即输入输出都有影响&lt;/p&gt;

&lt;p&gt;我们再用一个具体的例子来看一下这个区分：
我们来看下客户端的代码：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
        mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mBookManager = IBookManager.Stub.asInterface(service);
                try {
                    mBookManager.registerListener(new IBookListener.Stub() {
                        @Override
                        public void onBookAdd(Book book) throws RemoteException {
                            Log.i(&quot;wlh &quot; , &quot;addBook callback : &quot; + book.name);
                        }
                    });
                    Book book = new Book();
                    book.name = &quot;TestBook&quot;;
                    mBookManager.addBook(book);
                    Log.i(&quot;wlh&quot;,  book.name);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
&lt;/pre&gt;
&lt;p&gt;&amp;lt;/code&amp;gt;&lt;/p&gt;

&lt;p&gt;我们输出了callback 调用addBook 和调用后book对象的名称。我们再来看下服务端的代码：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
    private IBinder mBinder = new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;getBookList&quot;);
            return null;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;addBook : &quot; + book.name);
            int N = mCallbacks.beginBroadcast();
            book.name += &quot; : server&quot;;
            for (int i = 0; i &amp;lt; N; i++ ) {
                mCallbacks.getBroadcastItem(i).onBookAdd(book);
            }
            mCallbacks.finishBroadcast();

        }

        @Override
        public void registerListener(IBookListener listener) throws RemoteException {
            mCallbacks.register(listener);
        }

        @Override
        public void unRegisterListener(IBookListener listener) throws RemoteException {
            mCallbacks.unregister(listener);
        }
    };
&amp;lt;/pre&amp;gt;
&amp;lt;/code&amp;gt;

观察addBook方法 我们在客户端传过来的book中修改了name字段 追加了一个：server，然后我们输出了客户端传递过来的book名称。现在我们来看在book的修饰符分别为in out 和inout时候的系统输出。（我们假设BookListener中的参数都是in,其实BookListener中的in out inout修饰就是起点 和 终点的转换，这个时候起点是调用方服务端 终点是响应方客户端，具体的读者可自行分析）  

in:   
 我们可以先猜测一下输出，in表示数据会传递到终点，那么服务端会输出TestBook，然后由于对对象的修改不会反映到起点，所以对象不会反映到客户端，客户端依然输出的是TestBook，而callback中的回调是TestBook : server,我们来看下实际效果：  

![](/images/aidl2-1.png)  

out:  
out不会将数据传递到终点在这里也就是服务端，那么服务端会输出null， 然后由于对象修改会反应到起点也就是客户端，所以客户端会输出 null : server,我们来看下实际效果：  
![](/images/aidl2-2.png)  

inout:
inout即会把数据传递到终点，起点也会响应终点的变化，那么服务端会输出 TestBook
然后客户端输出 TestBook : server, 我们来看下实际效果：  
![](/images/aidl2-3.png)  

&lt;/Book&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.在AIDL的时候正确使用in out inout</summary></entry><entry><title type="html">IPC之AIDL(1)实现AIDL</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-1/" rel="alternate" type="text/html" title="IPC之AIDL(1)实现AIDL" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-1</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-1/">&lt;p&gt;内容大纲&lt;/p&gt;
&lt;pre&gt;
1.使用AIDL实现IPC
&lt;/pre&gt;

&lt;p&gt;本文是基于Android studio来说明的。我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。&lt;/p&gt;

&lt;p&gt;##AIDL文件
AIDL 全程 Android Interface Definition Language，即接口定义语言。Android通过aidl文件将服务的接口公开，来实现跨进程的调用。 &lt;br /&gt;
在Android studio中创建aidl文件，你只需要右键-&amp;gt;新建 -&amp;gt;aidl即可，其目录结构基本如下：&lt;br /&gt;
&lt;img src=&quot;/images/ipc-aidle1-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来明确一些AIDL的规则：&lt;br /&gt;
1.aidl文件中的参数只能从以下类型选择： 基本数据类型， parcelable的类， Aidl接口&lt;br /&gt;
2.即使在同一个包下，aidl文件也必须指明import&lt;br /&gt;
3.parcelable的类作为方法参数时要指明in out inout&lt;br /&gt;
4.接口中使用到的Parcelable类 必须建立同名的aidl文件，包名必须与实际的java类文件相同&lt;/p&gt;

&lt;p&gt;我们来看一个具体的例子：&lt;br /&gt;
IBookManager.aidl：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.wlh.animation.ipctest;
import com.wlh.animation.ipctest.Book;
import com.wlh.animation.ipctest.IBookListener;

interface IBookManager {

    List&lt;Book&gt; getBookList();
    void addBook(in Book book);

    void registerListener(IBookListener listener);

    void unRegisterListener(IBookListener listener);
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;

Book.aidl:
&lt;pre&gt;
&lt;code&gt;
package com.wlh.animation.ipctest;
parcelable Book;
&lt;/code&gt;
&lt;/pre&gt;
在例子中我们定义了一个IBookManager的接口来实现进程通信，它又4个方法 getBookList()(不带参数)， add Book(in Book book)带Parcelable参数必须指明in out inout中的一个，registerListener 和 unRegisterListener，也是Aidl的接口。
写完aidl文件后我们 make一下可以看到系统为我们生成的类：  
![](/images/ipc-aidle1-2.png)  
关于系统为我们做了什么 我们在下一篇中再进行详细的介绍，现在我们来看一下服务端的代码实现：  
&lt;pre&gt;
&lt;code&gt;
public class AIDLService extends Service{
    RemoteCallbackList&lt;IBookListener&gt; mCallbacks = new RemoteCallbackList&amp;lt;&amp;gt;();
    private IBinder mBinder = new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;getBookList&quot;);
            return null;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;addBook : &quot; + book.name);
            int N = mCallbacks.beginBroadcast();
            book.name += &quot; : server&quot;;
            for (int i = 0; i &amp;lt; N; i++ ) {
                mCallbacks.getBroadcastItem(i).onBookAdd(book);
            }
            mCallbacks.finishBroadcast();

        }

        @Override
        public void registerListener(IBookListener listener) throws RemoteException {
            mCallbacks.register(listener);
        }

        @Override
        public void unRegisterListener(IBookListener listener) throws RemoteException {
            mCallbacks.unregister(listener);
        }
    };

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;
我们只要实现IBookManager.Stub 然后再onBind方法中返回即可，我们再来看下客户端是如何实现的：  
&lt;pre&gt;
&lt;code&gt;
        mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mBookManager = IBookManager.Stub.asInterface(service);
                try {
                    mBookManager.registerListener(new IBookListener.Stub() {
                        @Override
                        public void onBookAdd(Book book) throws RemoteException {
                            Log.i(&quot;wlh &quot; , &quot;addBook callback : &quot; + book.name);
                        }
                    });
                    Book book = new Book();
                    book.name = &quot;TestBook&quot;;
                    mBookManager.addBook(book);
                    Log.i(&quot;wlh&quot;,  book.name);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
      
&lt;/code&gt;
&lt;/pre&gt;
我们以Bind的方式启动Service然后再onServiceConnected中的使用IBookManager.Stub.asInterface来转换成我们定义的接口即可实现和服务端的交互。 
&lt;/Book&gt;&lt;/IBookListener&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/Book&gt;&lt;/code&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲 1.使用AIDL实现IPC 本文是基于Android studio来说明的。我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。</summary></entry><entry><title type="html">ReactNative调研报告</title><link href="http://localhost:4000/2017/05/11/react-native-report/" rel="alternate" type="text/html" title="ReactNative调研报告" /><published>2017-05-11T00:00:00+00:00</published><updated>2017-05-11T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/11/react-native-report</id><content type="html" xml:base="http://localhost:4000/2017/05/11/react-native-report/">&lt;p&gt;2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。&lt;/p&gt;

&lt;h2 id=&quot;reactnative简介&quot;&gt;ReactNative简介&lt;/h2&gt;
&lt;p&gt;在reactnative中文网上有以下简介:&lt;/p&gt;
&lt;pre&gt;
React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。  
React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)  
Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。
&lt;/pre&gt;
&lt;p&gt;React Native是使用javascript和react来实现跨平台开发的, React Native提倡组件化开发: 即提供一个个封装好的组件，组件相互嵌套形成新的组件.你可以完全将App使用ReactNative编写，也可以使用原生和react native混合和的方式。由于目前React Native才发布到0.44版本，还没有发布正式的1.0, 其变动相对比较频繁，在react native升级后经常导致项目不能运行，你必须去做额外的工作来保证项目正常的运行。不过最近React Native的发布已经慢慢趋于稳定了，现在基本是1-2个月发一次版本更新，更新内容也没有之前变化那么大了。&lt;/p&gt;

&lt;p&gt;众所周知Android的碎片化和厂商的定制化是影响app稳定的很重要的原因之一,尤其是在国内，各个手机厂商都对Android系统进行了深度定制。这样的问题在ReactNative上也有很明显的体现，ReactNative在兼容Android各个系统版本和厂商版本的时候会暴露出不少的问题，目前React Native只支持Android 4.1以上，IOS 7.0以上的版本.附上最新的Android版本分布，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25737474&quot;&gt;Android3月份分版本分布&lt;/a&gt;可以看到Android 4.0的应用占比基本在%1左右，所以影响不大。&lt;/p&gt;

&lt;p&gt;在2017年3月爆发了一股苹果商店禁止热更新的事件，很多人都担心苹果是否会封掉Reactnative，其实苹果想要禁止的是热更新的功能。在苹果的拒绝邮件上也只是说明拒绝热更新的能力。从目前来看，这2个月苹果ReactNative依然可以过审。在各个论坛上也并未发现此次禁止热更新对ReactNative有较为明显的影响。&lt;/p&gt;

&lt;h2 id=&quot;reactnative-vs-原生-vs-hybrid&quot;&gt;ReactNative VS 原生 VS Hybrid&lt;/h2&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;(hybrid和 phoneGap APICloud AppCan等思想相同)
hybrid是一款h5的跨终端的解决方案，思想是 编写一次，就可以跨平台。
本质上hybrid还是web界面，只不过针对各个平台提供了一些调用native方法的api，通过js 和 native交互进行通信。&lt;br /&gt;
用web渲染界面是比较耗时的，为了解决界面的渲染耗时，react-native将界面用原生实现，而js部分只负责描述界面并将描述后的界面通过js和native的交互机制通知给终端，让终端根据js传递过来的界面描述信息来选择本地的控件进行界面的拼装。react-native的思想是 学习一次，可以跨平台开发（仍需要各个终端的人配合）。&lt;/p&gt;

&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;原生 &amp;gt; ReactNative &amp;gt; Hybrid&lt;br /&gt;
具体的性能对比参数可以查看&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发维护&quot;&gt;开发&amp;amp;维护&lt;/h3&gt;
&lt;p&gt;以下成本和更新能力模块参考了&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;维护成本&quot;&gt;维护成本&lt;/h3&gt;
&lt;p&gt;Hybrid &amp;lt; ReactNative &amp;lt; 原生&lt;br /&gt;
Hybrid是H5的夸平台解决方案，ReactNative可以达到百分之90左右的代码共用，但仍需要终端支持。&lt;/p&gt;

&lt;p&gt;H5/Hybird： Web代码 ＋ iOS/Android平台支持&lt;/p&gt;

&lt;p&gt;React Native：可以一个开发团队 ＋ iOS/Android工程师；业务组件颗粒度小，不用把握全局即可修改业务代码。&lt;/p&gt;

&lt;p&gt;Native：iOS/Android开发周期长，两个开发团队。&lt;/p&gt;

&lt;p&gt;总结：React Native 统一了开发人员技术栈，代码维护相对容易。&lt;/p&gt;
&lt;h4 id=&quot;更新能力&quot;&gt;更新能力&lt;/h4&gt;
&lt;p&gt;H5/Hybird： 随时更新，适合做营销页面，目前携程一些BU全部都是H5页面；但是重要的部分还是Native。&lt;/p&gt;

&lt;p&gt;React Native：React Native部分可以热更新，bug及时修复。&lt;/p&gt;

&lt;p&gt;Native：随版本更新，尤其iOS审核严格，需要测试过关，否则影响用户。&lt;/p&gt;

&lt;h2 id=&quot;react-canvas&quot;&gt;React-Canvas&lt;/h2&gt;
&lt;p&gt;为了解决webapp渲染dom的效率问题，Flipboard推出了一款react-canvas，它的思想是用做游戏的方式来做app。界面渲染针对到canvas上，通过重新定义绘制过程来减少web界面渲染时候的开销问题。&lt;br /&gt;
react-canvas 也是使用的css-layout和react-native一致，也集成了react，只是最终界面是通过canvas展示的。
react-canvas因为是针对webapp的，所以它的灵活性要比react-native强，渲染的卡顿问题比较接近原生,由于react-canvas还是一个webapp所以有一些原生的界面效果不太好处理。react-canvas如果要和native交互需要单独提供本地的基础库和js和native的通信机制。
其实react-native可以理解成重写了一个简版的web浏览器，它只支持一些特殊的定制化界面，用native实现界面渲染来达到原生的体验效果。&lt;/p&gt;

&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;目前国内使用ReactNative的还不是很多（有些小的应用是完全用React Native来实现的）, 比较出名的是 携程的火车票模块， QQ空间，销售易的包中也发现了React Native的痕迹。要想看到更多的国内案例可以通过react native中文网收集的案例上查看: &lt;a href=&quot;http://reactnative.cn/cases.html&quot;&gt;ReactNative案例&lt;/a&gt;。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。</summary></entry><entry><title type="html">用gradle构建java项目</title><link href="http://localhost:4000/2017/05/03/gradle-server-project/" rel="alternate" type="text/html" title="用gradle构建java项目" /><published>2017-05-03T00:00:00+00:00</published><updated>2017-05-03T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/03/gradle-server-project</id><content type="html" xml:base="http://localhost:4000/2017/05/03/gradle-server-project/">&lt;p&gt;一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置&lt;/p&gt;

&lt;p&gt;IDE: idea&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先安装gradle 并配置环境变量&lt;/li&gt;
  &lt;li&gt;在项目目录下执行 gradle wrapper 生成wrapper文件（之后再idea中配置使用wrapper构建，使用wrapper的好处在于使用项目配置的gradle版本 不会因为版本冲突引发问题)可以通过–verison 来制定特定的版本&lt;/li&gt;
  &lt;li&gt;在idea 设置中搜索gradle 选择使用gradle wrapper 并勾选use-auto-import然后即可&lt;/li&gt;
  &lt;li&gt;根据需求自己定义setting.gradle 和 build.gradle中的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在新建完项目执行单元测试的时候你可能会遇到Error:gradle-resources-test:di_test: java.lang.NoClassDefFoundError: org/apache/tools/ant/util/ReaderInputStream 的错误这是你可以执行以下操作：&lt;br /&gt;
File → Invalidate Caches / Restart 然后重启idea即可&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置</summary></entry></feed>