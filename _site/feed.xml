<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-06-21T06:44:28+00:00</updated><id>http://localhost:4000/</id><title type="html">FSilence’s Blog</title><subtitle>FSilence的个人博客</subtitle><author><name>FSilence</name></author><entry><title type="html">okHttp各个module介绍</title><link href="http://localhost:4000/2017/06/13/okhttp-code-scanner/" rel="alternate" type="text/html" title="okHttp各个module介绍" /><published>2017-06-13T00:00:00+00:00</published><updated>2017-06-13T00:00:00+00:00</updated><id>http://localhost:4000/2017/06/13/okhttp-code-scanner</id><content type="html" xml:base="http://localhost:4000/2017/06/13/okhttp-code-scanner/">&lt;p&gt;上一篇我们简单介绍了okHttp，了解了OkHttp的基本用法，并下载了okhttp的源码。本篇我们将一起来看看okhttp源码的目录结构，来大概了解下okHttp源码下的各个module的作用。&lt;/p&gt;

&lt;p&gt;okHttp的构建工具使用的是maven，关于&lt;a href=&quot;https://www.google.com.hk/#safe=strict&amp;amp;q=maven&quot;&gt;maven&lt;/a&gt;可自行google,本文不对此做过多阐述。我们来重点看一下okHttp的项目目录。在这里以及之后的源码都是okHttp的最新版本 3.8.0。我们可以选择git工具checkout出 3.8.0的tag，本人使用的是idea自带的git管理工具，在右下角git分支出点击 选测checkout tag, 输入3.8.0的分支名字：parent-3.8.0 确认即可, 然后我们来看一下项目的目录结构截图:&lt;br /&gt;
&lt;img src=&quot;/images/okhttp/okhttp-modules.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来看看各个module的功能作用，主要的借阅资料是module下的README.MD文件，读者也可自行查阅。&lt;/p&gt;

&lt;h2 id=&quot;benchmarks&quot;&gt;benchmarks&lt;/h2&gt;
&lt;p&gt;README.MD中的说明:&lt;/p&gt;
&lt;pre&gt;
This module allows you to test the performance of HTTP clients.
Running
  1. If you made modifications to `Benchmark` run `mvn compile`.
  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
&lt;/pre&gt;

&lt;p&gt;用google caliper来测试HTTP客户端性能的，具体的使用我们先不加关注。&lt;/p&gt;

&lt;h2 id=&quot;mockwebserver&quot;&gt;mockwebserver&lt;/h2&gt;
&lt;p&gt;README.MD中的说明，我们这里只截取了介绍部分，具体的使用说明不做说明。&lt;/p&gt;
&lt;pre&gt;
A scriptable web server for testing HTTP clients    
**Motivation**  
This library makes it easy to test that your app Does The Right Thing when it
makes HTTP and HTTPS calls. It lets you specify which responses to return and
then verify that requests were made as expected.  
Because it exercises your full HTTP stack, you can be confident that you're
testing everything. You can even copy &amp;amp; paste HTTP responses from your real web
server to create representative test cases. Or test that your code survives in
awkward-to-reproduce situations like 500 errors or slow-loading responses.  
**Example**   
Use MockWebServer the same way that you use mocking frameworks like
[Mockito](https://github.com/mockito/mockito):
1. Script the mocks.
2. Run application code.
3. Verify that the expected requests were made.
&lt;/pre&gt;
&lt;p&gt;此处省略了具体的demo部分，大致是说MockWebServer是用来在单元测试中来模拟网络请求用的，我们可以模拟一个网络返回来验证我们的网络调用。&lt;/p&gt;

&lt;h2 id=&quot;okcurl&quot;&gt;okcurl&lt;/h2&gt;
&lt;p&gt;来看README文件:&lt;/p&gt;
&lt;pre&gt;
_A curl for the next-generation web._  
OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
HTTP/2) against web servers.
&lt;/pre&gt;
&lt;p&gt;用来离线测试okhttp引擎的。&lt;/p&gt;

&lt;h2 id=&quot;okhttp&quot;&gt;okhttp&lt;/h2&gt;
&lt;p&gt;我们将要研究的项目主体。&lt;/p&gt;

&lt;h2 id=&quot;okhttp-android-support-okhttp-urlconnection-okhttp-apache&quot;&gt;okhttp-android-support okhttp-urlconnection okhttp-apache&lt;/h2&gt;
&lt;p&gt;对其它http引擎的适配。&lt;/p&gt;

&lt;h2 id=&quot;okhttp-hpacktests&quot;&gt;okhttp-hpacktests&lt;/h2&gt;
&lt;pre&gt;
These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
implementation.  The HPACK test cases are in a separate git submodule, so to
initialize them, you must run:

    git submodule init
    git submodule update

TODO
----

 * Add maven goal to avoid manual call to git submodule init.
 * Make hpack-test-case update itself from git, and run new tests.
 * Add maven goal to generate stories and a pull request to hpack-test-case
   to have others validate our output.

[1]: https://github.com/http2jp/hpack-test-case 
&lt;/pre&gt;
&lt;p&gt;这个是用来测试hpack的。HPACK是http 2.0的头部压缩算法。&lt;/p&gt;

&lt;h2 id=&quot;okhttp-loggin-interceptor&quot;&gt;okhttp-loggin-interceptor&lt;/h2&gt;
&lt;pre&gt;
An [OkHttp interceptor][1] which logs HTTP request and response data.
&lt;/pre&gt;
&lt;p&gt;日志输出的拦截器，关于interceptor之后再分析OkHttp的代码中我们会看到它的具体含义和使用。&lt;/p&gt;

&lt;h2 id=&quot;okhttp-testing-support&quot;&gt;okhttp-testing-support&lt;/h2&gt;
&lt;p&gt;对okhttp测试的一些基础能力支持。&lt;/p&gt;

&lt;h2 id=&quot;okhttp-tests&quot;&gt;okhttp-tests&lt;/h2&gt;
&lt;p&gt;okhttp自己的测试&lt;/p&gt;

&lt;h2 id=&quot;samples&quot;&gt;samples&lt;/h2&gt;
&lt;p&gt;demo&lt;/p&gt;

&lt;h2 id=&quot;website&quot;&gt;website&lt;/h2&gt;
&lt;p&gt;okhttp的介绍说明的静态网页。&lt;/p&gt;

&lt;p&gt;我们已大致了解了okhttp下的各个module，在后面的文章中我们将开始逐步进入okhttp的具体代码，来一步一步学习okhttp。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">上一篇我们简单介绍了okHttp，了解了OkHttp的基本用法，并下载了okhttp的源码。本篇我们将一起来看看okhttp源码的目录结构，来大概了解下okHttp源码下的各个module的作用。</summary></entry><entry><title type="html">OkHttp源码初探</title><link href="http://localhost:4000/2017/06/13/okhttp-client-simple/" rel="alternate" type="text/html" title="OkHttp源码初探" /><published>2017-06-13T00:00:00+00:00</published><updated>2017-06-13T00:00:00+00:00</updated><id>http://localhost:4000/2017/06/13/okhttp-client-simple</id><content type="html" xml:base="http://localhost:4000/2017/06/13/okhttp-client-simple/">&lt;p&gt;在之前的文章我中我们介绍了OkHttp的基本使用方法并简单说明了源码下各个module的功能作用，从这篇开始我们将要开始分析okHttp的源码。&lt;/p&gt;

&lt;p&gt;首先，我们先来回忆一下OkHttp的使用过程: 
1.创建一个OkHttpClient对象&lt;br /&gt;
2.创建一个Request对象&lt;br /&gt;
3.调用OkHttpClient的newCall方法创建request的Call实例&lt;br /&gt;
4.调用Call的execute 或 enqeue方法分别启动同步异步请求获取Response&lt;/p&gt;

&lt;p&gt;上述我们涉及到几个概念OkHttpClient, Request, Call, Response 我们将分别来分析一下这些内容。&lt;/p&gt;

&lt;h2 id=&quot;request&quot;&gt;Request&lt;/h2&gt;
&lt;p&gt;一个Request是一次请求的抽象，我们先简单看下里面的参数:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpUrl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Headers&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到一个Request 基本包含一个请求的url 请求的方法， Headers 和 请求的body，还有一个tag。&lt;br /&gt;
关于Request的具体内容，我们会在后面的系列文章中来进行分析。&lt;/p&gt;

&lt;h2 id=&quot;okhttpclient&quot;&gt;OkHttpClient&lt;/h2&gt;
&lt;p&gt;我们可以看到OkHttpClient基本上是和okHttp打交道的门户，我们先来看一下OkHttpClient的定义:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OkHttpClient&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cloneable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WebSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Factory&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到OkHttpClient实现了接口Call.Factory 和 WebSocket,Factory顾名思义，OkHttpClient将负责创建Call 和 WebSocket的实例，在这里我们先对WebSocket不做考虑，我们讲桌布分析Http的请求。&lt;/p&gt;

&lt;p&gt;OkHttpClient使用了创建者模式，使用一个Builder对象来控制构建一个OkHttpClient所需的各项配置，我们来看一下Builder中的参数:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Protocol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectionSpec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionSpecs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networkInterceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventListenerFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProxySelector&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxySelector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CookieJar&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cookieJar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalCache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internalCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SocketFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socketFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SSLSocketFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sslSocketFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CertificateChainCleaner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;certificateChainCleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HostnameVerifier&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hostnameVerifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CertificatePinner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;certificatePinner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Authenticator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyAuthenticator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Authenticator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authenticator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConnectionPool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;followSslRedirects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;followRedirects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retryOnConnectionFailure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pingInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;除了一些Http的配置外，我们可以看到3个特殊的概念配置，分别是EventListener.Factory Dispatcher 和 Interceptor&lt;br /&gt;
我们先来看一下EventListener 至于Dispatcher 和 interceptor我们会在系列文章的后续部分看到详细的分析，其中Dispatcher是来管理分发请求任务的，Interceptor是拦截器。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NONE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetchStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dnsStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domainName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dnsEnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domainName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InetAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inetAddressList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connectStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InetAddress&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;secureConnectStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;secureConnectEnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handshake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handshake&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connectEnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;InetAddress&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestHeadersStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestHeadersEnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到EventListener是对请求过程中各个步骤的事件监听.&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;Call&lt;/h2&gt;
&lt;p&gt;一次具体的请求, OkHttpClient通过newCall创建了call对象，通过call对象的execute 或 enqeue来发起请求&lt;/p&gt;

&lt;h2 id=&quot;response&quot;&gt;Response&lt;/h2&gt;
&lt;p&gt;网络返回的结果，我们将在后续文章中进行详细的解析。&lt;/p&gt;

&lt;p&gt;现在我们已经了解了在okHttp启动中的几个概念 其中有入口 OkHttpClient, 请求的实例Request 请求的抽象Call 拦截器Interceptor 分发管理Call的Dispatcher http的返回响应 Response, 我们还阅读了OkHttpClient的源码, 在下一篇中我们将要详细分析Call的体系结构。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">在之前的文章我中我们介绍了OkHttp的基本使用方法并简单说明了源码下各个module的功能作用，从这篇开始我们将要开始分析okHttp的源码。</summary></entry><entry><title type="html">okHttp之请求Call</title><link href="http://localhost:4000/2017/06/13/okhttp-call/" rel="alternate" type="text/html" title="okHttp之请求Call" /><published>2017-06-13T00:00:00+00:00</published><updated>2017-06-13T00:00:00+00:00</updated><id>http://localhost:4000/2017/06/13/okhttp-call</id><content type="html" xml:base="http://localhost:4000/2017/06/13/okhttp-call/">&lt;p&gt;前一篇我们简单介绍了OkHttp中的几个常见的概念，我们知道OkHttpClient是请求的门户（外观模式），通过OkHttpClient创建了一个Call对象，然后通过Call对象来实现网络的请求，本篇我们来看一下Call做同步和异步时候都做了些什么。&lt;/p&gt;

&lt;p&gt;首先，我们先来看一下Call Dispatcher OkHttpClient 等的类关系图:&lt;br /&gt;
&lt;img src=&quot;/images/okhttp/call-class.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到OkHttpClient实现了Call.Factory方法负责生产Call对象，查看OkHttpClient中的newCall方法可以发现，创建的是一个RealCall对象，RealCall对象持有OkHttpClient来方便使用OkHttpCLient中的配置项等。 在RealCall中有一个内部类AsyncCall是对RealCall的一次封装，在做异步请求的时候会用到这个对象。&lt;/p&gt;

&lt;h2 id=&quot;同步请求&quot;&gt;同步请求&lt;/h2&gt;
&lt;p&gt;现在我们来看一下同步请求的调用过程， 我们先来看一下调用的序列图:&lt;br /&gt;
&lt;img src=&quot;/images/okhttp/sync-call-seq.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
同步请求的调用过程可以总结为:&lt;br /&gt;
1.调用Dispatcher的execute方法&lt;br /&gt;
2.调用getResponseWithInterceptorChain方法获取结果Respone(具体的过程，我们之后再来做研究)&lt;br /&gt;
3.调用Dispatcher的finish方法，通知请求结束&lt;/p&gt;

&lt;h2 id=&quot;异步请求&quot;&gt;异步请求&lt;/h2&gt;
&lt;p&gt;异步请求和同步调用表现基本一致，不过在异步中，RealCall中是通过封装了一个AsyncCall（一个Runnable）然后再交给Dispatcher的，然后再AsyncCall的execute方法中，依然是通过getResponseWithInterceptorChain来获取结果，然后再调用Dispatcher的finish方法来通知Dispatcher任务结束。我们来看下异步请求的序列图:&lt;br /&gt;
&lt;img src=&quot;/images/okhttp/async-call-seq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;getresponsewithinterceptorchain&quot;&gt;getResponseWithInterceptorChain&lt;/h2&gt;
&lt;p&gt;之前我们介绍了，不管是同步还是异步获取Response都是通过RealCall中的getResponseWithInterceptorChain方法。我们来看下方法的实现;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getResponseWithInterceptorChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Build a full stack of interceptors.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retryAndFollowUpInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BridgeInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cookieJar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;internalCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConnectInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forWebSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;networkInterceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CallServerInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forWebSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Chain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RealInterceptorChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;interceptors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;originalRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;proceed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到 首先由一个interceptors的列表，然后调用Interceptor.Chain的proceed方法，可以理解会依次触发Interceptor并最终返回Response, 至于各个Interceptor的作用，我们在下一篇中再来做详细的讨论。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">前一篇我们简单介绍了OkHttp中的几个常见的概念，我们知道OkHttpClient是请求的门户（外观模式），通过OkHttpClient创建了一个Call对象，然后通过Call对象来实现网络的请求，本篇我们来看一下Call做同步和异步时候都做了些什么。</summary></entry><entry><title type="html">okhttp-简介</title><link href="http://localhost:4000/2017/06/09/okhttp-introduce/" rel="alternate" type="text/html" title="okhttp-简介" /><published>2017-06-09T00:00:00+00:00</published><updated>2017-06-09T00:00:00+00:00</updated><id>http://localhost:4000/2017/06/09/okhttp-introduce</id><content type="html" xml:base="http://localhost:4000/2017/06/09/okhttp-introduce/">&lt;p&gt;An HTTP &amp;amp; HTTP/2 client for Android and Java applications&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp&quot;&gt;okhttp github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;okhttp简介&quot;&gt;okhttp简介&lt;/h2&gt;
&lt;p&gt;okhttp是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Square%E5%85%AC%E5%8F%B8&quot;&gt;square公司&lt;/a&gt;以Apache License, Version 2.0开源的一个网络框架。&lt;br /&gt;
在现在的网络应用中，我们一般都是用HTTP来做数据交换的，一个高效的HTTP可以让你应用加载更快并节省带宽。&lt;br /&gt;
OkHttp有以下的优势:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;支持Http2(支持相同host的请求共享socket通道)&lt;/li&gt;
  &lt;li&gt;如果Http2不能使用，会有连接池来降低请求等待时间&lt;/li&gt;
  &lt;li&gt;通过gzip压缩减少sizes&lt;/li&gt;
  &lt;li&gt;responese缓存, 减少重复请求&lt;/li&gt;
  &lt;li&gt;OKHttp默认支持失败重连，如果你有多个IP地址，在服务失败后OKHttp将尝试切换请求的IP&lt;/li&gt;
  &lt;li&gt;OKhttp默认支持TLS的新版特性(SNI, ALPN),如果握手失败将自动降级到TLS 1.0.OkHttp引用了OkIo的项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OkHttp引用了OkIo的项目,&lt;a href=&quot;https://github.com/square/okio&quot;&gt;OkIo&lt;/a&gt;是对javaIO的扩展和简化。  &lt;br /&gt;
OkHttp支持同步和异步的请求，最低支持Android 2.3  java 1.7的版本。&lt;br /&gt;
我们可以把okhttp看成是Appach Http的替代品。&lt;/p&gt;
&lt;h2 id=&quot;okhttp基本使用&quot;&gt;okhttp基本使用&lt;/h2&gt;
&lt;h3 id=&quot;okhttp引用&quot;&gt;okhttp引用&lt;/h3&gt;
&lt;p&gt;直接下载jar包（需要引入okIo的jar包）&lt;/p&gt;

&lt;p&gt;MAVEN:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.squareup.okhttp3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;okhttp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GRADLE:&lt;/p&gt;
&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;compile&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.squareup.okhttp3:okhttp:3.8.0'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;GET A URL:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;kHttpClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OkHttpClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;POST TO A SERVER:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MediaType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSON&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MediaType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;OkHttpClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OkHttpClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RequestBody&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;源码下载&quot;&gt;源码下载&lt;/h2&gt;
&lt;p&gt;github : &lt;a href=&quot;https://github.com/square/okhttp&quot;&gt;okhttp github&lt;/a&gt; &lt;br /&gt;
IDE: idea &lt;br /&gt;
我们用git clone项目到本地即可, 项目是maven项目我使用的是idea编译器，我们用idea导入项目，然后同步maven即可。&lt;/p&gt;

&lt;p&gt;下一篇我们来介绍okhttp项目下的各个module。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">An HTTP &amp;amp; HTTP/2 client for Android and Java applications</summary></entry><entry><title type="html">Mac Shell的配置</title><link href="http://localhost:4000/2017/05/23/mac-shell-config/" rel="alternate" type="text/html" title="Mac Shell的配置" /><published>2017-05-23T00:00:00+00:00</published><updated>2017-05-23T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/23/mac-shell-config</id><content type="html" xml:base="http://localhost:4000/2017/05/23/mac-shell-config/">&lt;p&gt;要想方便的使用mac，shell的使用个人认为是必不可少的，在我们拿到mac的时候，我们应该先配置好我们的shell，这样可以极大的提高我们的效率。本文不会描述具体的配置过程，只是对相关配置资料的一个索引。&lt;/p&gt;

&lt;h2 id=&quot;zsh&quot;&gt;zsh&lt;/h2&gt;
&lt;p&gt;为什么我要使用zsh 而不是bash，可以参照&lt;a href=&quot;https://www.zhihu.com/question/21418449&quot;&gt;为什么说 zsh 是 shell 中的极品？
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mac安装zsh: &lt;br /&gt;
zsh的配置能力非常强，如果你要自己完全配置zsh你会发现非常非常复杂，还好有人给我我们提供了不错的配置方案 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;on-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;配置zsh:&lt;br /&gt;
zsh的配置在文件 ~/.zshrc中，我们可以在其中使用别名，配置插件等提高shell的使用效率。&lt;br /&gt;
zsh的具体配置可以参照&lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/24a0ded2e3ba&quot;&gt;在osx中配置和使用zsh&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/ii1245712564/article/details/45843657&quot;&gt; zsh安装和配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Terminal自动开启zsh:&lt;br /&gt;
安装好on-my-zsh后，我们可以在 ~/.bash_profile中 添加一行 zsh，这样每次启动terminal的时候就都是zsh&lt;/p&gt;

&lt;h2 id=&quot;安装autojump&quot;&gt;安装autojump&lt;/h2&gt;
&lt;p&gt;通过 brew 安装autojump:&lt;/p&gt;
&lt;pre&gt;
brew install autojump
&lt;/pre&gt;

&lt;p&gt;在 ~/.zshrc中加入以下内容&lt;/p&gt;
&lt;pre&gt;
[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . ~/.autojump/etc/profile.d/autojump.sh
&lt;/pre&gt;

&lt;p&gt;然后重新启动zsh，就可以通过j + 目录名跳转到任何你cd过的目录中，支持模糊匹配。&lt;/p&gt;

&lt;h2 id=&quot;配置vi&quot;&gt;配置vi&lt;/h2&gt;
&lt;p&gt;vi的插件管理 参考 &lt;a href=&quot;http://blog.csdn.net/zhangpower1993/article/details/52184581&quot;&gt;VBundle的介绍及安装&lt;/a&gt;&lt;br /&gt;
vi的插件统建 参考 &lt;a href=&quot;http://blog.csdn.net/namecyf/article/details/7787479&quot;&gt;vi配置及插件管理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://fsilence.com/wiki/mac-bash/&quot;&gt;osx shell快捷键&lt;/a&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">要想方便的使用mac，shell的使用个人认为是必不可少的，在我们拿到mac的时候，我们应该先配置好我们的shell，这样可以极大的提高我们的效率。本文不会描述具体的配置过程，只是对相关配置资料的一个索引。</summary></entry><entry><title type="html">window的showAsDropDown失效的问题</title><link href="http://localhost:4000/2017/05/17/popupwindow-showAsDropDown/" rel="alternate" type="text/html" title="window的showAsDropDown失效的问题" /><published>2017-05-17T00:00:00+00:00</published><updated>2017-05-17T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/17/popupwindow-showAsDropDown</id><content type="html" xml:base="http://localhost:4000/2017/05/17/popupwindow-showAsDropDown/">&lt;p&gt;在使用Popupwindow的showAsDropDown的时候，有时候会在特定机型上无法正确显示（全屏显示了）。&lt;/p&gt;

&lt;p&gt;目前的解决方案是如果需要全屏显示的popwindow，要计算出window的实际高度然后调用popupwindow的setHeight方法后再调用showAdDropDown即可。&lt;br /&gt;
获取PopupWindow的实际高度:&lt;/p&gt;
&lt;pre&gt;
    public static void showPopwindow(Context context, PopupWindow popupWindow, View anchor) {
        int[] locations = new int[2];
        anchor.getLocationOnScreen(locations);
        int screenHeight = context.getApplicationContext().getResources().getDisplayMetrics(); 
	int height = screenHeight - anchor.getHeight() - locations[1];
        popupWindow.setHeight(height);
        popupWindow.showAsDropDown(anchor);
    }
&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">在使用Popupwindow的showAsDropDown的时候，有时候会在特定机型上无法正确显示（全屏显示了）。</summary></entry><entry><title type="html">multidex找不到的问题</title><link href="http://localhost:4000/2017/05/17/as-multidex-notfound/" rel="alternate" type="text/html" title="multidex找不到的问题" /><published>2017-05-17T00:00:00+00:00</published><updated>2017-05-17T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/17/as-multidex-notfound</id><content type="html" xml:base="http://localhost:4000/2017/05/17/as-multidex-notfound/">&lt;p&gt;最近将AndroidStudio升级到了2.3， 然后发现instan run不好使了，要求Gradle插件版本必须是2.3以上，所以讲gradle插件版本修改为2.3.1，然后发现点击运行会报错：程序包：multidex 找不到。&lt;/p&gt;

&lt;p&gt;在之前的版本中只要配置好multidex = true 插件会自动引用multidex的包，升级到2.3.1后不能自动引用 只能手动添加了, 在dependencies中添加：&lt;br /&gt;
 compile “com.android.support:multidex:1.0.1” 即可。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">最近将AndroidStudio升级到了2.3， 然后发现instan run不好使了，要求Gradle插件版本必须是2.3以上，所以讲gradle插件版本修改为2.3.1，然后发现点击运行会报错：程序包：multidex 找不到。</summary></entry><entry><title type="html">IPC之Messenger</title><link href="http://localhost:4000/2017/05/16/ipc-messenger/" rel="alternate" type="text/html" title="IPC之Messenger" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/ipc-messenger</id><content type="html" xml:base="http://localhost:4000/2017/05/16/ipc-messenger/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.学会使用Messenger进行进程间通信
&lt;/pre&gt;

&lt;p&gt;在进行具体的探讨之前，我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。&lt;/p&gt;

&lt;p&gt;Messenger可以理解为信使，它可以实现消息的发送，底层使用Binder实现的（所以可以跨进程）。我们来看Messenger的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   public Messenger(IBinder target) {
        mTarget = IMessenger.Stub.asInterface(target);
    }

   public Messenger(Handler target) {
        mTarget = target.getIMessenger();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Messenger的构造函数主要有2个 一个 接受一个IBinder参数 一个接受一个Handler参数，我们可以看到它们参数的名称都是叫target，从字面上我们也不难理解，这个参数的作用就是定义消息发送的目标。我们看下Handler中MessengerImpl的具体实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    private final class MessengerImpl extends IMessenger.Stub {
        public void send(Message msg) {
            msg.sendingUid = Binder.getCallingUid();
            Handler.this.sendMessage(msg);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到在发送消息的时候，给msg添加了一个属性，CallingUid,这个CallingUid又是什么呢，我们来看一下Binder中的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  /**
     * Return the Linux uid assigned to the process that sent you the
     * current transaction that is being processed.  This uid can be used with
     * higher-level system services to determine its identity and check
     * permissions.  If the current thread is not currently executing an
     * incoming transaction, then its own uid is returned.
     */
    public static final native int getCallingUid();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难发现这个UId其实就是调用方进程的UID(用户身份的标识符)。
那么这个IMessenger.Stub是什么呢？这里我们不加讨论，在AIDL的实现中我们会重点讨论这个。&lt;br /&gt;
我们接着再来看下如何用Messenger实现IPC，我们先看下客户端的实现:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在onServiceConnected中用返回的IBinder new一个Messenger（消息的发送者），然后创建Message直接send即可，那么服务端又是如何接收处理这个消息的呢：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class MessengerService extends Service{
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };
    Messenger messenger = new Messenger(handler);
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return messenger.getBinder();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端的实现也很简单 定义一个Handler 和 Messenger（消息的接收者，交给Handler处理） 然后返回messenger的getBinder即可。这样我们就实现了进程的单向通信，那么如何实现双向通信呢，其实也很简单我们只要给message添加一个replyTo的对象（也是一个Messenger）然后使用这个replyTo就可以进行消息的应答。其实我们可以思考一下如果我们需要实现双向沟通是不是需要一个发送者来发送消息， 一个接收者来接受消息。我们来一下基于上面单向通信的改进，首先来看客户端的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  	Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;reply info : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };

    Messenger receiveMessenger = new Messenger(handler);

     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
				message.replyTo = receiveMessenger;
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现在单向通信的基础上我们添加了一个接收者 receiverMessenter, 然后将其赋值给msg的replyTo， 服务端就可以取到这个Messenger来进行消息回复。&lt;br /&gt;
我们再来看下服务端的改进：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
            Message replyMsg = new Message();
            Bundle data = new Bundle();
            data.putString(&quot;info&quot;, &quot; this is from server&quot;);
            replyMsg.setData(data);
            try {
                msg.replyTo.send(replyMsg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要通过msg.replyTo来发送消息回复就可以了，是不是很简单。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.学会使用Messenger进行进程间通信</summary></entry><entry><title type="html">EventBus Q&amp;amp;A</title><link href="http://localhost:4000/2017/05/16/eventbus-qa/" rel="alternate" type="text/html" title="EventBus Q&amp;A" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/eventbus-qa</id><content type="html" xml:base="http://localhost:4000/2017/05/16/eventbus-qa/">&lt;p&gt;阅读EventBus源码过程中总结的一些问题和答案&lt;/p&gt;

&lt;h3 id=&quot;eventbus-中如果一个subscriber中的父类也注册了相同的监听事件以哪个为准&quot;&gt;EventBus 中如果一个subscriber中的父类也注册了相同的监听事件，以哪个为准&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;以子类中的事件为准，在SubscriberMethodFinder方法中，在添加一个subscribeMethod的时候  会调用FindState的checkAdd方法，其中有这么一段逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                // Only add if not already found in a sub class
                return true;
            } else {
                // Revert the put, old class is further down the class hierarchy
                subscriberClassByMethodKey.put(methodKey, methodClassOld);
                return false;
            }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果原先注册过的methodClass 是当前想要注册的methodClass的父类的话，返回true，（isAssignableFrom 判断类是否是另一个类的父类）
在结束后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 if (findState.checkAdd(method, eventType)) {
ThreadMode threadMode = subscribeAnnotation.threadMode();
findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果checkAdd返回了true的话 表示可以添加当前method到列表中&lt;/p&gt;

&lt;p&gt;###SubscribeMethodFinder中的FindStat有什么用
FindStat用来记录一次查找的中间变量和结果，其中的superClass用来帮助查找器进行递归查找。&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的event-对象是如何管理的&quot;&gt;EventBus中的event 对象是如何管理的&lt;/h3&gt;
&lt;p&gt;当用户通过post来发送一个消息的时候，EventBus会首先获取一个PostThreadStat对象（通过ThreadLocal存放的 每个线程都会有一份，来记录当前线程的一些发送状态），然后将消息放入到PostThreadStat中的event队列，然后会依次取队列中的消息，进行发送操作。&lt;br /&gt;
单次的发送操作： 
如果eventInheritance为true(默认为true)，就先查找出所有的父类 和 接口，都记录为event，发送，如果为false 则只发送当前消息。如果没有找到对应的订阅者，则抛出一个NoSubscriberEvent的消息。如果有订阅者，则根据订阅者的类型来选择发送的方式。&lt;br /&gt;
EventBus中有3个变量来保存消息，1.subscriptionsByEventType 一个Map,key是eventType value是subscribtions，主要用来post消息的时候可以找到对应的subscribtion来换起方法。2.typesBySubscriber 一个Map,key是订阅者 value是订阅的事件列表，主要用来在unregister订阅者的时候方便去清空对应的数据。3.stickyEvents 主要是用来存放sticky消息的。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的register的过程&quot;&gt;EventBus的register的过程&lt;/h3&gt;
&lt;p&gt;register一个订阅者的时候，会进行以下几步：&lt;br /&gt;
1.通过subscriberMethodFinder查找到所有注释的订阅方法&lt;br /&gt;
2.循环依次注册方法&lt;br /&gt;
3.每一次注册的时候，根据优先级加入到列表中（subscriptionsByEventType的value），优先级高的在前面&lt;br /&gt;
4.更新typesBySubscriber&lt;br /&gt;
5.如果注册的方法是sticky的，则检查当前的stickyEvents列表，触发sticky消息的相应&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder的查找过程&quot;&gt;SubscriberMethodFinder的查找过程&lt;/h3&gt;
&lt;p&gt;Finder中每次查找结果都有缓存（不会有泄露 因为缓存的应用都是Class Method这些）,可以通过EventBus的clearCache来清空。（我们可以考虑在onLowMemory的时候调用此方法）
SubscirberMethodFinder中有一个FindStat类用来帮助记录一次查找的中间状态和结果 以及帮助递归查找（里面有一个superClass的参数），每次遍历类和父类找到注册方法。&lt;br /&gt;
FindStat中有一个checkAdd方法 来判断当前方法是否应该添加到subscribMethod中。在checkAdd方法中，会根据当前类是否注册过来判断是否可以添加。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的poststicky-和-post消息有什么区别&quot;&gt;EventBus的postSticky 和 post消息有什么区别&lt;/h3&gt;
&lt;p&gt;post过程见上。&lt;br /&gt;
postSticky 先将消息放入到stickyEvents的map中 然后再调用post消息&lt;/p&gt;

&lt;h3 id=&quot;eventbus的threadmode类型&quot;&gt;EventBus的threadMode类型&lt;/h3&gt;
&lt;p&gt;POSTING:在发送事件的线程中通知订阅者&lt;br /&gt;
MAIN:如果当前是主线程直接通知订阅者，否则调用HandlePoster的enque方法在主线程中通知订阅者&lt;br /&gt;
BACKGROUD:如果当前不是主线程中则直接通知订阅者，否则启动一个后台线程来通知订阅者（不同的消息共用一个线程）&lt;br /&gt;
ASYN:启动不同的线程来通知订阅者&lt;/p&gt;

&lt;p&gt;HandlerPoster:帮助主线程中的调度，其中维护一个PendingPost的队列，在handleMessage中依次弹出消息并通知。&lt;/p&gt;

&lt;p&gt;BackgroundPoster:帮助实现BACKGROUND模式，BackgroundPoster本身是一个runable，通过enque一个event对象，如果当前有线程正在处理post消息则直接在此线程中处理，否则会通过eventBus调用
builder中设置的线程池来执行线程（在run方法中循环取出消息队列中的消息来处理）&lt;/p&gt;

&lt;p&gt;AsyncPoster：帮助实现ASYN模式，本事是一个Runnable,enque一个event对象后会直接换起线程池来执行线程，在run中poll一个消息来处理&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的eventtypescache是干什么用的&quot;&gt;EventBus中的eventTypesCache是干什么用的&lt;/h3&gt;
&lt;p&gt;在eventInheritance为true的时候 会通过发送的event对象 查找event对象的所有父类和接口，这个cache就是用来缓存这个的。&lt;br /&gt;
通过clearCaches来清空缓存&lt;/p&gt;

&lt;h3 id=&quot;如何理解pendingpost&quot;&gt;如何理解PendingPost&lt;/h3&gt;
&lt;p&gt;PendingPost是一次post的意图，其中定义了要发送的事件event 和 订阅方法 以及next 意图（用来和pendingPostQueue配合 实现队列）&lt;/p&gt;

&lt;h3 id=&quot;eventbus中用到了哪些设计模式&quot;&gt;EventBus中用到了哪些设计模式&lt;/h3&gt;
&lt;p&gt;创建者模式： Builder&lt;br /&gt;
订阅者模式： 整体就是订阅模式&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder中的findstat是如何确定一个方法是否应该被记录的&quot;&gt;*SubscriberMethodFinder中的FindStat是如何确定一个方法是否应该被记录的&lt;/h3&gt;
&lt;p&gt;（重点是FindStat中的2个临时变量 之后再做补充说明）&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">阅读EventBus源码过程中总结的一些问题和答案</summary></entry><entry><title type="html">IPC之AIDL(3)系统为我们做了什么</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/" rel="alternate" type="text/html" title="IPC之AIDL(3)系统为我们做了什么" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-3</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.了解基本的aidl原理（不涉及底层）
&lt;/pre&gt;

&lt;p&gt;前面几篇我们介绍了如何使用AIDL实现IPC 那么你会有疑问了 我们用的asInterface是什么， Stub又是什么，现在让我们一点一点来看。在我们编译的时候，系统会吧aidl生成对应的java类（这就是为什么支持aidl这种文件格式了），我们先来看一下系统生成的类(本文涉及到的系统源码都是基于android-23)：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
package com.wlh.animation.ipctest;
// Declare any non-default types here with import statements

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.wlh.animation.ipctest.IBookManager {
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.wlh.animation.ipctest.IBookManager interface,
         * generating a proxy if needed.
         */
        public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
    		...
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                   ...
                }
                case TRANSACTION_getBookList: {
                   ...
                }
                case TRANSACTION_addBook: {
                  ...
                }
                case TRANSACTION_registerListener: {
                   ...
                }
                case TRANSACTION_unRegisterListener: {
                   ...
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.wlh.animation.ipctest.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException {
       			...
            }

            @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
     			...
            }

            @Override
            public void registerListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
               		...
            }

            @Override
            public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
          		...
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    }

    public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException;

    public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException;

    public void registerListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;

    public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;
}
&amp;lt;/pre&amp;gt;
&amp;lt;/code&amp;gt;

我们先忽略方法的具体实现，来看一下这个系统为我们生成的类中都有哪些东西：  
1.整个文件是一个IBookManager(你aidl文件名字)的接口 继承IInterface  
2.一个抽象类Stub继承Binder（前面我们说过  Binder有跨进程的能力）实现了这个IBookManager接口  
3.一个代理类实现了IBookManager(注意没有继承Binder)  
然后我们依次来解析一下这写类：  
##IBookManager IInterface 
首先是IBookManager,它是一个继承自IInterface的接口，我们先来看下IInterface接口中有哪些东西：  
&lt;pre&gt;
&lt;code&gt;
public interface IInterface
{
    public IBinder asBinder();
}
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到IInterface中只有一个方法 就是asBinder 返回一个IBinder,IBinder也是一个接口。

##Stub Binder
Stub是一个抽象类继承了Binder 实现了IBookManager接口

###Binder
Binder实现了IBinder，我们来看下IBinder中的内容.我们这里只介绍一些重要的变量和方法，其它的说明读者可自行查阅源码中的注释。  
###getInterfaceDescriptor
源码定义如下：  
&lt;pre&gt;
&lt;code&gt;
  /**
     * Get the canonical name of the interface supported by this binder.
     */
    public String getInterfaceDescriptor() throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个返回接口的名称，我们在Binder中可以看到它的具体实现：  
&lt;pre&gt;
&lt;code&gt;
   public void attachInterface(IInterface owner, String descriptor) {
        mOwner = owner;
        mDescriptor = descriptor;
    }

      public String getInterfaceDescriptor() {
        return mDescriptor;
    }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到系统通过attachInterface来给接口名称赋值，主要是为了作为跨进程通信时候接口的标识，我们可以在Binder的子类Stub也就是系统为我们生成的类中看到具体的接口名称：  
&lt;pre&gt;
&lt;code&gt;
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到其实就是接口的全路径。  

###pingBinder, isBinderAlive, 
&lt;pre&gt;
&lt;code&gt;
  /**
     * Check to see if the object still exists.
     * 
     * @return Returns false if the
     * hosting process is gone, otherwise the result (always by default
     * true) returned by the pingBinder() implementation on the other
     * side.
     */
    public boolean pingBinder();
&lt;/code&gt;
&lt;/pre&gt;
就是字面意思ping一下 来确认Binder是否可以链接到Binder，只有当宿主进程不存在的时候才返回false。  

&lt;pre&gt;
&lt;code&gt;
   /**
     * Check to see if the process that the binder is in is still alive.
     *
     * @return false if the process is not alive.  Note that if it returns
     * true, the process may have died while the call is returning.
     */
    public boolean isBinderAlive();
&lt;/code&gt;
&lt;/pre&gt;
返回Binder是否存活。如果进程不是存活状态，那么返回false。  


###queryLocalInterface

&lt;pre&gt;
&lt;code&gt;
 /**
     * Attempt to retrieve a local implementation of an interface
     * for this Binder object.  If null is returned, you will need
     * to instantiate a proxy class to marshall calls through
     * the transact() method.
     */
    public IInterface queryLocalInterface(String descriptor);
&lt;/code&gt;
&lt;/pre&gt;
根据接口的描述返回一个本地接口，如果返回的是null的话（就是跨进程），需要你去实现代理（在使用aidl的时候系统为我们已经实现好了）  


###transact
&lt;pre&gt;
&lt;code&gt;
/**
     * Perform a generic operation with the object.
     * 
     * @param code The action to perform.  This should
     * be a number between {@link #FIRST_CALL_TRANSACTION} and
     * {@link #LAST_CALL_TRANSACTION}.
     * @param data Marshalled data to send to the target.  Must not be null.
     * If you are not sending any data, you must create an empty Parcel
     * that is given here.
     * @param reply Marshalled data to be received from the target.  May be
     * null if you are not interested in the return value.
     * @param flags Additional operation flags.  Either 0 for a normal
     * RPC, or {@link #FLAG_ONEWAY} for a one-way RPC.
     */
    public boolean transact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个基本上是IBinder中最重要的一个函数了，它用来相应对象的操作，例如我们本例中的一个addBook操作，它的参数主要有如下几个：  
1.code 一次操作的唯一标识，要介于常量FIRST_CALL_TRANSACTION（ 0x00000001）和 LAST_CALL_TRANSACTION（0x00ffffff）之间  

2.data 需要传递的数据不能为空   

3.reply 返回的数据  

4.flats 附加的操作标识，通常返回0. 如果设置成FLAG_ONEWAY表示呼叫方不会等待被呼叫方放回结果（只在跨进程的时候生效）。  


我们再来看下Stub中的具体实现：  

###asInterface
&lt;pre&gt;
&lt;code&gt;
     public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;amp;&amp;amp; (iin instanceof com.wlh.animation.ipctest.IBookManager))) {
                return ((com.wlh.animation.ipctest.IBookManager) iin);
            }
            return new com.wlh.animation.ipctest.IBookManager.Stub.Proxy(obj);
        }
&lt;/code&gt;
&lt;/pre&gt;
将IBinder转换成我们需要的接口，我们可以看到基本的逻辑是：如果从本地找到了接口就返回本地接口（没有跨进程），否则返回Stub的代理类，关于代理类我们稍后再说，这个逻辑规则基本贯穿了Stub中的所有方法：即先找本地，如果没有（跨进程）则返回代理。  

###onTransact
&lt;pre&gt;
&lt;code&gt;
 @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {


   switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_addBook: {
                   。。。
                }
}
}
&lt;/code&gt;
&lt;/pre&gt;
首先在Stub类中 系统为我们的每一个方法值都赋予了一个id
&lt;pre&gt;
    static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
&lt;/pre&gt;
可以看到是基于TRANSACTIOn_{$method name}来命名的参数是基于FIRST_CALL_TRANSACTION递增的。然后再onTransaction方法中系统会switch code判断当前调用的是哪个方法然后做相应的操作 我们来看下addBook的具体实现：  
&lt;pre&gt;
&lt;code&gt;
  case TRANSACTION_addBook: {
    data.enforceInterface(DESCRIPTOR);
                    com.wlh.animation.ipctest.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.wlh.animation.ipctest.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBook(_arg0);
                    reply.writeNoException();
                    if ((_arg0 != null)) {
                        reply.writeInt(1);
                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
	}
&lt;/code&gt;
&lt;/pre&gt;  
我们不难看出，基本思路就是将对象和Parceable之间转换处理。  

我们再来看下代理类Proxy:  
Proxy是实现了接口IBookManager的代理类，其构造方法如下：  
&lt;pre&gt;
&lt;code&gt;
  Proxy(android.os.IBinder remote) {
                mRemote = remote;
   }
&lt;/code&gt;
&lt;/pre&gt;

构造函数是一个IBinder,之后代理中的相关调用都会转到这个Binder中去处理，我们还是来看一下addBookManager接口：  
&lt;pre&gt;
&lt;code&gt;
     @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
                    _reply.readException();
                    if ((0 != _reply.readInt())) {
                        book.readFromParcel(_reply);
                    }
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
&lt;/code&gt;
&lt;/pre&gt;

可以看到和onTransact中最大的区别在于 它将具体的处理时间交给了跨进程的Binder处理。  

以上就是在我们编写AIDL文件后 系统为我们生成文件的解析。




&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.了解基本的aidl原理（不涉及底层）</summary></entry></feed>