<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-05-16T07:47:14+00:00</updated><id>http://localhost:4000/</id><title type="html">FSilence’s Blog</title><subtitle>FSilence的个人博客</subtitle><author><name>FSilence</name></author><entry><title type="html">IPC之Messenger</title><link href="http://localhost:4000/2017/05/16/ipc-messenger/" rel="alternate" type="text/html" title="IPC之Messenger" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/ipc-messenger</id><content type="html" xml:base="http://localhost:4000/2017/05/16/ipc-messenger/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.学会使用Messenger进行进程间通信
&lt;/pre&gt;

&lt;p&gt;在进行具体的探讨之前，我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。&lt;/p&gt;

&lt;p&gt;Messenger可以理解为信使，它可以实现消息的发送，底层使用Binder实现的（所以可以跨进程）。我们来看Messenger的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   public Messenger(IBinder target) {
        mTarget = IMessenger.Stub.asInterface(target);
    }

   public Messenger(Handler target) {
        mTarget = target.getIMessenger();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Messenger的构造函数主要有2个 一个 接受一个IBinder参数 一个接受一个Handler参数，我们可以看到它们参数的名称都是叫target，从字面上我们也不难理解，这个参数的作用就是定义消息发送的目标。我们看下Handler中MessengerImpl的具体实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    private final class MessengerImpl extends IMessenger.Stub {
        public void send(Message msg) {
            msg.sendingUid = Binder.getCallingUid();
            Handler.this.sendMessage(msg);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到在发送消息的时候，给msg添加了一个属性，CallingUid,这个CallingUid又是什么呢，我们来看一下Binder中的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  /**
     * Return the Linux uid assigned to the process that sent you the
     * current transaction that is being processed.  This uid can be used with
     * higher-level system services to determine its identity and check
     * permissions.  If the current thread is not currently executing an
     * incoming transaction, then its own uid is returned.
     */
    public static final native int getCallingUid();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难发现这个UId其实就是调用方进程的UID(用户身份的标识符)。
那么这个IMessenger.Stub是什么呢？这里我们不加讨论，在AIDL的实现中我们会重点讨论这个。&lt;br /&gt;
我们接着再来看下如何用Messenger实现IPC，我们先看下客户端的实现:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在onServiceConnected中用返回的IBinder new一个Messenger（消息的发送者），然后创建Message直接send即可，那么服务端又是如何接收处理这个消息的呢：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class MessengerService extends Service{
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };
    Messenger messenger = new Messenger(handler);
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return messenger.getBinder();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端的实现也很简单 定义一个Handler 和 Messenger（消息的接收者，交给Handler处理） 然后返回messenger的getBinder即可。这样我们就实现了进程的单向通信，那么如何实现双向通信呢，其实也很简单我们只要给message添加一个replyTo的对象（也是一个Messenger）然后使用这个replyTo就可以进行消息的应答。其实我们可以思考一下如果我们需要实现双向沟通是不是需要一个发送者来发送消息， 一个接收者来接受消息。我们来一下基于上面单向通信的改进，首先来看客户端的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  	Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;reply info : &quot; + msg.getData().getString(&quot;info&quot;));
        }
    };

    Messenger receiveMessenger = new Messenger(handler);

     mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Messenger messenger = new Messenger(service);
                Message message = new Message();
                Bundle data = new Bundle();
                data.putString(&quot;info&quot;, &quot;this is from client&quot;);
                message.setData(data);
				message.replyTo = receiveMessenger;
                try {
                    messenger.send(message);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
        bindService(new Intent(this, MessengerService.class), mServiceConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现在单向通信的基础上我们添加了一个接收者 receiverMessenter, 然后将其赋值给msg的replyTo， 服务端就可以取到这个Messenger来进行消息回复。&lt;br /&gt;
我们再来看下服务端的改进：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Log.i(&quot;wlh&quot;, &quot;service : &quot; + msg.getData().getString(&quot;info&quot;));
            Message replyMsg = new Message();
            Bundle data = new Bundle();
            data.putString(&quot;info&quot;, &quot; this is from server&quot;);
            replyMsg.setData(data);
            try {
                msg.replyTo.send(replyMsg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要通过msg.replyTo来发送消息回复就可以了，是不是很简单。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.学会使用Messenger进行进程间通信</summary></entry><entry><title type="html">EventBus Q&amp;amp;A</title><link href="http://localhost:4000/2017/05/16/eventbus-qa/" rel="alternate" type="text/html" title="EventBus Q&amp;A" /><published>2017-05-16T00:00:00+00:00</published><updated>2017-05-16T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/16/eventbus-qa</id><content type="html" xml:base="http://localhost:4000/2017/05/16/eventbus-qa/">&lt;p&gt;阅读EventBus源码过程中总结的一些问题和答案&lt;/p&gt;

&lt;h3 id=&quot;eventbus-中如果一个subscriber中的父类也注册了相同的监听事件以哪个为准&quot;&gt;EventBus 中如果一个subscriber中的父类也注册了相同的监听事件，以哪个为准&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;以子类中的事件为准，在SubscriberMethodFinder方法中，在添加一个subscribeMethod的时候  会调用FindState的checkAdd方法，其中有这么一段逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
   if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
                // Only add if not already found in a sub class
                return true;
            } else {
                // Revert the put, old class is further down the class hierarchy
                subscriberClassByMethodKey.put(methodKey, methodClassOld);
                return false;
            }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果原先注册过的methodClass 是当前想要注册的methodClass的父类的话，返回true，（isAssignableFrom 判断类是否是另一个类的父类）
在结束后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 if (findState.checkAdd(method, eventType)) {
ThreadMode threadMode = subscribeAnnotation.threadMode();
findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果checkAdd返回了true的话 表示可以添加当前method到列表中&lt;/p&gt;

&lt;p&gt;###SubscribeMethodFinder中的FindStat有什么用
FindStat用来记录一次查找的中间变量和结果，其中的superClass用来帮助查找器进行递归查找。&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的event-对象是如何管理的&quot;&gt;EventBus中的event 对象是如何管理的&lt;/h3&gt;
&lt;p&gt;当用户通过post来发送一个消息的时候，EventBus会首先获取一个PostThreadStat对象（通过ThreadLocal存放的 每个线程都会有一份，来记录当前线程的一些发送状态），然后将消息放入到PostThreadStat中的event队列，然后会依次取队列中的消息，进行发送操作。&lt;br /&gt;
单次的发送操作： 
如果eventInheritance为true(默认为true)，就先查找出所有的父类 和 接口，都记录为event，发送，如果为false 则只发送当前消息。如果没有找到对应的订阅者，则抛出一个NoSubscriberEvent的消息。如果有订阅者，则根据订阅者的类型来选择发送的方式。&lt;br /&gt;
EventBus中有3个变量来保存消息，1.subscriptionsByEventType 一个Map,key是eventType value是subscribtions，主要用来post消息的时候可以找到对应的subscribtion来换起方法。2.typesBySubscriber 一个Map,key是订阅者 value是订阅的事件列表，主要用来在unregister订阅者的时候方便去清空对应的数据。3.stickyEvents 主要是用来存放sticky消息的。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的register的过程&quot;&gt;EventBus的register的过程&lt;/h3&gt;
&lt;p&gt;register一个订阅者的时候，会进行以下几步：&lt;br /&gt;
1.通过subscriberMethodFinder查找到所有注释的订阅方法&lt;br /&gt;
2.循环依次注册方法&lt;br /&gt;
3.每一次注册的时候，根据优先级加入到列表中（subscriptionsByEventType的value），优先级高的在前面&lt;br /&gt;
4.更新typesBySubscriber&lt;br /&gt;
5.如果注册的方法是sticky的，则检查当前的stickyEvents列表，触发sticky消息的相应&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder的查找过程&quot;&gt;SubscriberMethodFinder的查找过程&lt;/h3&gt;
&lt;p&gt;Finder中每次查找结果都有缓存（不会有泄露 因为缓存的应用都是Class Method这些）,可以通过EventBus的clearCache来清空。（我们可以考虑在onLowMemory的时候调用此方法）
SubscirberMethodFinder中有一个FindStat类用来帮助记录一次查找的中间状态和结果 以及帮助递归查找（里面有一个superClass的参数），每次遍历类和父类找到注册方法。&lt;br /&gt;
FindStat中有一个checkAdd方法 来判断当前方法是否应该添加到subscribMethod中。在checkAdd方法中，会根据当前类是否注册过来判断是否可以添加。&lt;/p&gt;

&lt;h3 id=&quot;eventbus的poststicky-和-post消息有什么区别&quot;&gt;EventBus的postSticky 和 post消息有什么区别&lt;/h3&gt;
&lt;p&gt;post过程见上。&lt;br /&gt;
postSticky 先将消息放入到stickyEvents的map中 然后再调用post消息&lt;/p&gt;

&lt;h3 id=&quot;eventbus的threadmode类型&quot;&gt;EventBus的threadMode类型&lt;/h3&gt;
&lt;p&gt;POSTING:在发送事件的线程中通知订阅者&lt;br /&gt;
MAIN:如果当前是主线程直接通知订阅者，否则调用HandlePoster的enque方法在主线程中通知订阅者&lt;br /&gt;
BACKGROUD:如果当前不是主线程中则直接通知订阅者，否则启动一个后台线程来通知订阅者（不同的消息共用一个线程）&lt;br /&gt;
ASYN:启动不同的线程来通知订阅者&lt;/p&gt;

&lt;p&gt;HandlerPoster:帮助主线程中的调度，其中维护一个PendingPost的队列，在handleMessage中依次弹出消息并通知。&lt;/p&gt;

&lt;p&gt;BackgroundPoster:帮助实现BACKGROUND模式，BackgroundPoster本身是一个runable，通过enque一个event对象，如果当前有线程正在处理post消息则直接在此线程中处理，否则会通过eventBus调用
builder中设置的线程池来执行线程（在run方法中循环取出消息队列中的消息来处理）&lt;/p&gt;

&lt;p&gt;AsyncPoster：帮助实现ASYN模式，本事是一个Runnable,enque一个event对象后会直接换起线程池来执行线程，在run中poll一个消息来处理&lt;/p&gt;

&lt;h3 id=&quot;eventbus中的eventtypescache是干什么用的&quot;&gt;EventBus中的eventTypesCache是干什么用的&lt;/h3&gt;
&lt;p&gt;在eventInheritance为true的时候 会通过发送的event对象 查找event对象的所有父类和接口，这个cache就是用来缓存这个的。&lt;br /&gt;
通过clearCaches来清空缓存&lt;/p&gt;

&lt;h3 id=&quot;如何理解pendingpost&quot;&gt;如何理解PendingPost&lt;/h3&gt;
&lt;p&gt;PendingPost是一次post的意图，其中定义了要发送的事件event 和 订阅方法 以及next 意图（用来和pendingPostQueue配合 实现队列）&lt;/p&gt;

&lt;h3 id=&quot;eventbus中用到了哪些设计模式&quot;&gt;EventBus中用到了哪些设计模式&lt;/h3&gt;
&lt;p&gt;创建者模式： Builder&lt;br /&gt;
订阅者模式： 整体就是订阅模式&lt;/p&gt;

&lt;h3 id=&quot;subscribermethodfinder中的findstat是如何确定一个方法是否应该被记录的&quot;&gt;*SubscriberMethodFinder中的FindStat是如何确定一个方法是否应该被记录的&lt;/h3&gt;
&lt;p&gt;（重点是FindStat中的2个临时变量 之后再做补充说明）&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">阅读EventBus源码过程中总结的一些问题和答案</summary></entry><entry><title type="html">IPC之AIDL(3)系统为我们做了什么</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/" rel="alternate" type="text/html" title="IPC之AIDL(3)系统为我们做了什么" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-3</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-3/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.了解基本的aidl原理（不涉及底层）
&lt;/pre&gt;

&lt;p&gt;前面几篇我们介绍了如何使用AIDL实现IPC 那么你会有疑问了 我们用的asInterface是什么， Stub又是什么，现在让我们一点一点来看。在我们编译的时候，系统会吧aidl生成对应的java类（这就是为什么支持aidl这种文件格式了），我们先来看一下系统生成的类(本文涉及到的系统源码都是基于android-23)：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
package com.wlh.animation.ipctest;
// Declare any non-default types here with import statements

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.wlh.animation.ipctest.IBookManager {
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.wlh.animation.ipctest.IBookManager interface,
         * generating a proxy if needed.
         */
        public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
    		...
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                   ...
                }
                case TRANSACTION_getBookList: {
                   ...
                }
                case TRANSACTION_addBook: {
                  ...
                }
                case TRANSACTION_registerListener: {
                   ...
                }
                case TRANSACTION_unRegisterListener: {
                   ...
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.wlh.animation.ipctest.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException {
       			...
            }

            @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
     			...
            }

            @Override
            public void registerListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
               		...
            }

            @Override
            public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener)
                    throws android.os.RemoteException {
          		...
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    }

    public java.util.List&lt;com.wlh.animation.ipctest.Book&gt; getBookList() throws android.os.RemoteException;

    public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException;

    public void registerListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;

    public void unRegisterListener(com.wlh.animation.ipctest.IBookListener listener) throws android.os.RemoteException;
}
&amp;lt;/pre&amp;gt;
&amp;lt;/code&amp;gt;

我们先忽略方法的具体实现，来看一下这个系统为我们生成的类中都有哪些东西：  
1.整个文件是一个IBookManager(你aidl文件名字)的接口 继承IInterface  
2.一个抽象类Stub继承Binder（前面我们说过  Binder有跨进程的能力）实现了这个IBookManager接口  
3.一个代理类实现了IBookManager(注意没有继承Binder)  
然后我们依次来解析一下这写类：  
##IBookManager IInterface 
首先是IBookManager,它是一个继承自IInterface的接口，我们先来看下IInterface接口中有哪些东西：  
&lt;pre&gt;
&lt;code&gt;
public interface IInterface
{
    public IBinder asBinder();
}
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到IInterface中只有一个方法 就是asBinder 返回一个IBinder,IBinder也是一个接口。

##Stub Binder
Stub是一个抽象类继承了Binder 实现了IBookManager接口

###Binder
Binder实现了IBinder，我们来看下IBinder中的内容.我们这里只介绍一些重要的变量和方法，其它的说明读者可自行查阅源码中的注释。  
###getInterfaceDescriptor
源码定义如下：  
&lt;pre&gt;
&lt;code&gt;
  /**
     * Get the canonical name of the interface supported by this binder.
     */
    public String getInterfaceDescriptor() throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个返回接口的名称，我们在Binder中可以看到它的具体实现：  
&lt;pre&gt;
&lt;code&gt;
   public void attachInterface(IInterface owner, String descriptor) {
        mOwner = owner;
        mDescriptor = descriptor;
    }

      public String getInterfaceDescriptor() {
        return mDescriptor;
    }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到系统通过attachInterface来给接口名称赋值，主要是为了作为跨进程通信时候接口的标识，我们可以在Binder的子类Stub也就是系统为我们生成的类中看到具体的接口名称：  
&lt;pre&gt;
&lt;code&gt;
        private static final java.lang.String DESCRIPTOR = &quot;com.wlh.animation.ipctest.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }
&lt;/code&gt;
&lt;/pre&gt;
我们可以看到其实就是接口的全路径。  

###pingBinder, isBinderAlive, 
&lt;pre&gt;
&lt;code&gt;
  /**
     * Check to see if the object still exists.
     * 
     * @return Returns false if the
     * hosting process is gone, otherwise the result (always by default
     * true) returned by the pingBinder() implementation on the other
     * side.
     */
    public boolean pingBinder();
&lt;/code&gt;
&lt;/pre&gt;
就是字面意思ping一下 来确认Binder是否可以链接到Binder，只有当宿主进程不存在的时候才返回false。  

&lt;pre&gt;
&lt;code&gt;
   /**
     * Check to see if the process that the binder is in is still alive.
     *
     * @return false if the process is not alive.  Note that if it returns
     * true, the process may have died while the call is returning.
     */
    public boolean isBinderAlive();
&lt;/code&gt;
&lt;/pre&gt;
返回Binder是否存活。如果进程不是存活状态，那么返回false。  


###queryLocalInterface

&lt;pre&gt;
&lt;code&gt;
 /**
     * Attempt to retrieve a local implementation of an interface
     * for this Binder object.  If null is returned, you will need
     * to instantiate a proxy class to marshall calls through
     * the transact() method.
     */
    public IInterface queryLocalInterface(String descriptor);
&lt;/code&gt;
&lt;/pre&gt;
根据接口的描述返回一个本地接口，如果返回的是null的话（就是跨进程），需要你去实现代理（在使用aidl的时候系统为我们已经实现好了）  


###transact
&lt;pre&gt;
&lt;code&gt;
/**
     * Perform a generic operation with the object.
     * 
     * @param code The action to perform.  This should
     * be a number between {@link #FIRST_CALL_TRANSACTION} and
     * {@link #LAST_CALL_TRANSACTION}.
     * @param data Marshalled data to send to the target.  Must not be null.
     * If you are not sending any data, you must create an empty Parcel
     * that is given here.
     * @param reply Marshalled data to be received from the target.  May be
     * null if you are not interested in the return value.
     * @param flags Additional operation flags.  Either 0 for a normal
     * RPC, or {@link #FLAG_ONEWAY} for a one-way RPC.
     */
    public boolean transact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException;
&lt;/code&gt;
&lt;/pre&gt;
这个基本上是IBinder中最重要的一个函数了，它用来相应对象的操作，例如我们本例中的一个addBook操作，它的参数主要有如下几个：  
1.code 一次操作的唯一标识，要介于常量FIRST_CALL_TRANSACTION（ 0x00000001）和 LAST_CALL_TRANSACTION（0x00ffffff）之间  

2.data 需要传递的数据不能为空   

3.reply 返回的数据  

4.flats 附加的操作标识，通常返回0. 如果设置成FLAG_ONEWAY表示呼叫方不会等待被呼叫方放回结果（只在跨进程的时候生效）。  


我们再来看下Stub中的具体实现：  

###asInterface
&lt;pre&gt;
&lt;code&gt;
     public static com.wlh.animation.ipctest.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;amp;&amp;amp; (iin instanceof com.wlh.animation.ipctest.IBookManager))) {
                return ((com.wlh.animation.ipctest.IBookManager) iin);
            }
            return new com.wlh.animation.ipctest.IBookManager.Stub.Proxy(obj);
        }
&lt;/code&gt;
&lt;/pre&gt;
将IBinder转换成我们需要的接口，我们可以看到基本的逻辑是：如果从本地找到了接口就返回本地接口（没有跨进程），否则返回Stub的代理类，关于代理类我们稍后再说，这个逻辑规则基本贯穿了Stub中的所有方法：即先找本地，如果没有（跨进程）则返回代理。  

###onTransact
&lt;pre&gt;
&lt;code&gt;
 @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {


   switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_addBook: {
                   。。。
                }
}
}
&lt;/code&gt;
&lt;/pre&gt;
首先在Stub类中 系统为我们的每一个方法值都赋予了一个id
&lt;pre&gt;
    static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
        static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
        static final int TRANSACTION_unRegisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
&lt;/pre&gt;
可以看到是基于TRANSACTIOn_{$method name}来命名的参数是基于FIRST_CALL_TRANSACTION递增的。然后再onTransaction方法中系统会switch code判断当前调用的是哪个方法然后做相应的操作 我们来看下addBook的具体实现：  
&lt;pre&gt;
&lt;code&gt;
  case TRANSACTION_addBook: {
    data.enforceInterface(DESCRIPTOR);
                    com.wlh.animation.ipctest.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.wlh.animation.ipctest.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBook(_arg0);
                    reply.writeNoException();
                    if ((_arg0 != null)) {
                        reply.writeInt(1);
                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
	}
&lt;/code&gt;
&lt;/pre&gt;  
我们不难看出，基本思路就是将对象和Parceable之间转换处理。  

我们再来看下代理类Proxy:  
Proxy是实现了接口IBookManager的代理类，其构造方法如下：  
&lt;pre&gt;
&lt;code&gt;
  Proxy(android.os.IBinder remote) {
                mRemote = remote;
   }
&lt;/code&gt;
&lt;/pre&gt;

构造函数是一个IBinder,之后代理中的相关调用都会转到这个Binder中去处理，我们还是来看一下addBookManager接口：  
&lt;pre&gt;
&lt;code&gt;
     @Override
            public void addBook(com.wlh.animation.ipctest.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
                    _reply.readException();
                    if ((0 != _reply.readInt())) {
                        book.readFromParcel(_reply);
                    }
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
&lt;/code&gt;
&lt;/pre&gt;

可以看到和onTransact中最大的区别在于 它将具体的处理时间交给了跨进程的Binder处理。  

以上就是在我们编写AIDL文件后 系统为我们生成文件的解析。




&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/com.wlh.animation.ipctest.Book&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.了解基本的aidl原理（不涉及底层）</summary></entry><entry><title type="html">IPC之AIDL(2)in out inout</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-2/" rel="alternate" type="text/html" title="IPC之AIDL(2)in out inout" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-2</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-2/">&lt;p&gt;内容大纲：&lt;/p&gt;
&lt;pre&gt;
1.在AIDL的时候正确使用in out inout
&lt;/pre&gt;

&lt;p&gt;上一篇我们用AIDL简单实现了一个IPC，其中我们谈到在定义aidl接口中的除基本类型和AIDL接口外的参数要调价修饰符in out 或 inout中的一种，本文将帮助大家理解in out inout，并让读者可以正确的使用in out inout。&lt;br /&gt;
在介绍in out inout的区别之前我们先明确两个基本概念：起点 和 终点，起点指调用方，终点指响应方，比如我在客户端调用aidl接口那么客户端就是起点 服务端就是重点，在一次调用中服务端如果要调用一个aidl接口回调给客户端，那么服务端就是起点，客户端就是重点。&lt;br /&gt;
然后我们来定义in out inout:&lt;br /&gt;
in ： 将对象从起点传递给终点，在终点部分中对对象的修改不会反映到起点，即只输入&lt;br /&gt;
out : 对象中的值不会传递给终点，但是在终点部分对对象的修改会反映到起点，即只输出&lt;br /&gt;
intout : 将对象从起点传递给终点，在终点部分的修改会反应到起点，即输入输出都有影响&lt;/p&gt;

&lt;p&gt;我们再用一个具体的例子来看一下这个区分：
我们来看下客户端的代码：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
        mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mBookManager = IBookManager.Stub.asInterface(service);
                try {
                    mBookManager.registerListener(new IBookListener.Stub() {
                        @Override
                        public void onBookAdd(Book book) throws RemoteException {
                            Log.i(&quot;wlh &quot; , &quot;addBook callback : &quot; + book.name);
                        }
                    });
                    Book book = new Book();
                    book.name = &quot;TestBook&quot;;
                    mBookManager.addBook(book);
                    Log.i(&quot;wlh&quot;,  book.name);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
&lt;/pre&gt;
&lt;p&gt;&amp;lt;/code&amp;gt;&lt;/p&gt;

&lt;p&gt;我们输出了callback 调用addBook 和调用后book对象的名称。我们再来看下服务端的代码：&lt;br /&gt;
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
    private IBinder mBinder = new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;getBookList&quot;);
            return null;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;addBook : &quot; + book.name);
            int N = mCallbacks.beginBroadcast();
            book.name += &quot; : server&quot;;
            for (int i = 0; i &amp;lt; N; i++ ) {
                mCallbacks.getBroadcastItem(i).onBookAdd(book);
            }
            mCallbacks.finishBroadcast();

        }

        @Override
        public void registerListener(IBookListener listener) throws RemoteException {
            mCallbacks.register(listener);
        }

        @Override
        public void unRegisterListener(IBookListener listener) throws RemoteException {
            mCallbacks.unregister(listener);
        }
    };
&amp;lt;/pre&amp;gt;
&amp;lt;/code&amp;gt;

观察addBook方法 我们在客户端传过来的book中修改了name字段 追加了一个：server，然后我们输出了客户端传递过来的book名称。现在我们来看在book的修饰符分别为in out 和inout时候的系统输出。（我们假设BookListener中的参数都是in,其实BookListener中的in out inout修饰就是起点 和 终点的转换，这个时候起点是调用方服务端 终点是响应方客户端，具体的读者可自行分析）  

in:   
 我们可以先猜测一下输出，in表示数据会传递到终点，那么服务端会输出TestBook，然后由于对对象的修改不会反映到起点，所以对象不会反映到客户端，客户端依然输出的是TestBook，而callback中的回调是TestBook : server,我们来看下实际效果：  

![](/images/aidl2-1.png)  

out:  
out不会将数据传递到终点在这里也就是服务端，那么服务端会输出null， 然后由于对象修改会反应到起点也就是客户端，所以客户端会输出 null : server,我们来看下实际效果：  
![](/images/aidl2-2.png)  

inout:
inout即会把数据传递到终点，起点也会响应终点的变化，那么服务端会输出 TestBook
然后客户端输出 TestBook : server, 我们来看下实际效果：  
![](/images/aidl2-3.png)  

&lt;/Book&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲： 1.在AIDL的时候正确使用in out inout</summary></entry><entry><title type="html">IPC之AIDL(1)实现AIDL</title><link href="http://localhost:4000/2017/05/12/IPC-AIDL-Android-1/" rel="alternate" type="text/html" title="IPC之AIDL(1)实现AIDL" /><published>2017-05-12T00:00:00+00:00</published><updated>2017-05-12T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/12/IPC-AIDL-Android-1</id><content type="html" xml:base="http://localhost:4000/2017/05/12/IPC-AIDL-Android-1/">&lt;p&gt;内容大纲&lt;/p&gt;
&lt;pre&gt;
1.使用AIDL实现IPC
&lt;/pre&gt;

&lt;p&gt;本文是基于Android studio来说明的。我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。&lt;/p&gt;

&lt;p&gt;##AIDL文件
AIDL 全程 Android Interface Definition Language，即接口定义语言。Android通过aidl文件将服务的接口公开，来实现跨进程的调用。 &lt;br /&gt;
在Android studio中创建aidl文件，你只需要右键-&amp;gt;新建 -&amp;gt;aidl即可，其目录结构基本如下：&lt;br /&gt;
&lt;img src=&quot;/images/ipc-aidle1-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来明确一些AIDL的规则：&lt;br /&gt;
1.aidl文件中的参数只能从以下类型选择： 基本数据类型， parcelable的类， Aidl接口&lt;br /&gt;
2.即使在同一个包下，aidl文件也必须指明import&lt;br /&gt;
3.parcelable的类作为方法参数时要指明in out inout&lt;br /&gt;
4.接口中使用到的Parcelable类 必须建立同名的aidl文件，包名必须与实际的java类文件相同&lt;/p&gt;

&lt;p&gt;我们来看一个具体的例子：&lt;br /&gt;
IBookManager.aidl：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.wlh.animation.ipctest;
import com.wlh.animation.ipctest.Book;
import com.wlh.animation.ipctest.IBookListener;

interface IBookManager {

    List&lt;Book&gt; getBookList();
    void addBook(in Book book);

    void registerListener(IBookListener listener);

    void unRegisterListener(IBookListener listener);
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;

Book.aidl:
&lt;pre&gt;
&lt;code&gt;
package com.wlh.animation.ipctest;
parcelable Book;
&lt;/code&gt;
&lt;/pre&gt;
在例子中我们定义了一个IBookManager的接口来实现进程通信，它又4个方法 getBookList()(不带参数)， add Book(in Book book)带Parcelable参数必须指明in out inout中的一个，registerListener 和 unRegisterListener，也是Aidl的接口。
写完aidl文件后我们 make一下可以看到系统为我们生成的类：  
![](/images/ipc-aidle1-2.png)  
关于系统为我们做了什么 我们在下一篇中再进行详细的介绍，现在我们来看一下服务端的代码实现：  
&lt;pre&gt;
&lt;code&gt;
public class AIDLService extends Service{
    RemoteCallbackList&lt;IBookListener&gt; mCallbacks = new RemoteCallbackList&amp;lt;&amp;gt;();
    private IBinder mBinder = new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;getBookList&quot;);
            return null;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            Log.i(&quot;wlh&quot;, &quot;addBook : &quot; + book.name);
            int N = mCallbacks.beginBroadcast();
            book.name += &quot; : server&quot;;
            for (int i = 0; i &amp;lt; N; i++ ) {
                mCallbacks.getBroadcastItem(i).onBookAdd(book);
            }
            mCallbacks.finishBroadcast();

        }

        @Override
        public void registerListener(IBookListener listener) throws RemoteException {
            mCallbacks.register(listener);
        }

        @Override
        public void unRegisterListener(IBookListener listener) throws RemoteException {
            mCallbacks.unregister(listener);
        }
    };

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;
我们只要实现IBookManager.Stub 然后再onBind方法中返回即可，我们再来看下客户端是如何实现的：  
&lt;pre&gt;
&lt;code&gt;
        mServiceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mBookManager = IBookManager.Stub.asInterface(service);
                try {
                    mBookManager.registerListener(new IBookListener.Stub() {
                        @Override
                        public void onBookAdd(Book book) throws RemoteException {
                            Log.i(&quot;wlh &quot; , &quot;addBook callback : &quot; + book.name);
                        }
                    });
                    Book book = new Book();
                    book.name = &quot;TestBook&quot;;
                    mBookManager.addBook(book);
                    Log.i(&quot;wlh&quot;,  book.name);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                unbindService(mServiceConnection);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        };
      
&lt;/code&gt;
&lt;/pre&gt;
我们以Bind的方式启动Service然后再onServiceConnected中的使用IBookManager.Stub.asInterface来转换成我们定义的接口即可实现和服务端的交互。 
&lt;/Book&gt;&lt;/IBookListener&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/Book&gt;&lt;/code&gt;&lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">内容大纲 1.使用AIDL实现IPC 本文是基于Android studio来说明的。我们先明确2个基本概念客户端和服务端。在本例中客户端是指发起处理请求的进程（app的主进程）， 服务端（service端）指一个另外一个提供服务的进程（主要是指service）。</summary></entry><entry><title type="html">ReactNative调研报告</title><link href="http://localhost:4000/2017/05/11/react-native-report/" rel="alternate" type="text/html" title="ReactNative调研报告" /><published>2017-05-11T00:00:00+00:00</published><updated>2017-05-11T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/11/react-native-report</id><content type="html" xml:base="http://localhost:4000/2017/05/11/react-native-report/">&lt;p&gt;2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。&lt;/p&gt;

&lt;h2 id=&quot;reactnative简介&quot;&gt;ReactNative简介&lt;/h2&gt;
&lt;p&gt;在reactnative中文网上有以下简介:&lt;/p&gt;
&lt;pre&gt;
React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。  
React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)  
Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。
&lt;/pre&gt;
&lt;p&gt;React Native是使用javascript和react来实现跨平台开发的, React Native提倡组件化开发: 即提供一个个封装好的组件，组件相互嵌套形成新的组件.你可以完全将App使用ReactNative编写，也可以使用原生和react native混合和的方式。由于目前React Native才发布到0.44版本，还没有发布正式的1.0, 其变动相对比较频繁，在react native升级后经常导致项目不能运行，你必须去做额外的工作来保证项目正常的运行。不过最近React Native的发布已经慢慢趋于稳定了，现在基本是1-2个月发一次版本更新，更新内容也没有之前变化那么大了。&lt;/p&gt;

&lt;p&gt;众所周知Android的碎片化和厂商的定制化是影响app稳定的很重要的原因之一,尤其是在国内，各个手机厂商都对Android系统进行了深度定制。这样的问题在ReactNative上也有很明显的体现，ReactNative在兼容Android各个系统版本和厂商版本的时候会暴露出不少的问题，目前React Native只支持Android 4.1以上，IOS 7.0以上的版本.附上最新的Android版本分布，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25737474&quot;&gt;Android3月份分版本分布&lt;/a&gt;可以看到Android 4.0的应用占比基本在%1左右，所以影响不大。&lt;/p&gt;

&lt;p&gt;在2017年3月爆发了一股苹果商店禁止热更新的事件，很多人都担心苹果是否会封掉Reactnative，其实苹果想要禁止的是热更新的功能。在苹果的拒绝邮件上也只是说明拒绝热更新的能力。从目前来看，这2个月苹果ReactNative依然可以过审。在各个论坛上也并未发现此次禁止热更新对ReactNative有较为明显的影响。&lt;/p&gt;

&lt;h2 id=&quot;reactnative-vs-原生-vs-hybrid&quot;&gt;ReactNative VS 原生 VS Hybrid&lt;/h2&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;(hybrid和 phoneGap APICloud AppCan等思想相同)
hybrid是一款h5的跨终端的解决方案，思想是 编写一次，就可以跨平台。
本质上hybrid还是web界面，只不过针对各个平台提供了一些调用native方法的api，通过js 和 native交互进行通信。&lt;br /&gt;
用web渲染界面是比较耗时的，为了解决界面的渲染耗时，react-native将界面用原生实现，而js部分只负责描述界面并将描述后的界面通过js和native的交互机制通知给终端，让终端根据js传递过来的界面描述信息来选择本地的控件进行界面的拼装。react-native的思想是 学习一次，可以跨平台开发（仍需要各个终端的人配合）。&lt;/p&gt;

&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;原生 &amp;gt; ReactNative &amp;gt; Hybrid&lt;br /&gt;
具体的性能对比参数可以查看&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发维护&quot;&gt;开发&amp;amp;维护&lt;/h3&gt;
&lt;p&gt;以下成本和更新能力模块参考了&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;维护成本&quot;&gt;维护成本&lt;/h3&gt;
&lt;p&gt;Hybrid &amp;lt; ReactNative &amp;lt; 原生&lt;br /&gt;
Hybrid是H5的夸平台解决方案，ReactNative可以达到百分之90左右的代码共用，但仍需要终端支持。&lt;/p&gt;

&lt;p&gt;H5/Hybird： Web代码 ＋ iOS/Android平台支持&lt;/p&gt;

&lt;p&gt;React Native：可以一个开发团队 ＋ iOS/Android工程师；业务组件颗粒度小，不用把握全局即可修改业务代码。&lt;/p&gt;

&lt;p&gt;Native：iOS/Android开发周期长，两个开发团队。&lt;/p&gt;

&lt;p&gt;总结：React Native 统一了开发人员技术栈，代码维护相对容易。&lt;/p&gt;
&lt;h4 id=&quot;更新能力&quot;&gt;更新能力&lt;/h4&gt;
&lt;p&gt;H5/Hybird： 随时更新，适合做营销页面，目前携程一些BU全部都是H5页面；但是重要的部分还是Native。&lt;/p&gt;

&lt;p&gt;React Native：React Native部分可以热更新，bug及时修复。&lt;/p&gt;

&lt;p&gt;Native：随版本更新，尤其iOS审核严格，需要测试过关，否则影响用户。&lt;/p&gt;

&lt;h2 id=&quot;react-canvas&quot;&gt;React-Canvas&lt;/h2&gt;
&lt;p&gt;为了解决webapp渲染dom的效率问题，Flipboard推出了一款react-canvas，它的思想是用做游戏的方式来做app。界面渲染针对到canvas上，通过重新定义绘制过程来减少web界面渲染时候的开销问题。&lt;br /&gt;
react-canvas 也是使用的css-layout和react-native一致，也集成了react，只是最终界面是通过canvas展示的。
react-canvas因为是针对webapp的，所以它的灵活性要比react-native强，渲染的卡顿问题比较接近原生,由于react-canvas还是一个webapp所以有一些原生的界面效果不太好处理。react-canvas如果要和native交互需要单独提供本地的基础库和js和native的通信机制。
其实react-native可以理解成重写了一个简版的web浏览器，它只支持一些特殊的定制化界面，用native实现界面渲染来达到原生的体验效果。&lt;/p&gt;

&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;目前国内使用ReactNative的还不是很多（有些小的应用是完全用React Native来实现的）, 比较出名的是 携程的火车票模块， QQ空间，销售易的包中也发现了React Native的痕迹。要想看到更多的国内案例可以通过react native中文网收集的案例上查看: &lt;a href=&quot;http://reactnative.cn/cases.html&quot;&gt;ReactNative案例&lt;/a&gt;。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。</summary></entry><entry><title type="html">用gradle构建java项目</title><link href="http://localhost:4000/2017/05/03/gradle-server-project/" rel="alternate" type="text/html" title="用gradle构建java项目" /><published>2017-05-03T00:00:00+00:00</published><updated>2017-05-03T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/03/gradle-server-project</id><content type="html" xml:base="http://localhost:4000/2017/05/03/gradle-server-project/">&lt;p&gt;一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置&lt;/p&gt;

&lt;p&gt;IDE: idea&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先安装gradle 并配置环境变量&lt;/li&gt;
  &lt;li&gt;在项目目录下执行 gradle wrapper 生成wrapper文件（之后再idea中配置使用wrapper构建，使用wrapper的好处在于使用项目配置的gradle版本 不会因为版本冲突引发问题)可以通过–verison 来制定特定的版本&lt;/li&gt;
  &lt;li&gt;在idea 设置中搜索gradle 选择使用gradle wrapper 并勾选use-auto-import然后即可&lt;/li&gt;
  &lt;li&gt;根据需求自己定义setting.gradle 和 build.gradle中的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在新建完项目执行单元测试的时候你可能会遇到Error:gradle-resources-test:di_test: java.lang.NoClassDefFoundError: org/apache/tools/ant/util/ReaderInputStream 的错误这是你可以执行以下操作：&lt;br /&gt;
File → Invalidate Caches / Restart 然后重启idea即可&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置</summary></entry><entry><title type="html">IPC概述</title><link href="http://localhost:4000/2017/05/01/ipc-about/" rel="alternate" type="text/html" title="IPC概述" /><published>2017-05-01T00:00:00+00:00</published><updated>2017-05-01T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/01/ipc-about</id><content type="html" xml:base="http://localhost:4000/2017/05/01/ipc-about/">&lt;p&gt;摘要：&lt;/p&gt;
&lt;pre&gt;
1.什么是IPC
2.android实现IPC的几种方式
&lt;/pre&gt;

&lt;p&gt;##IPC
IPC全称Inter-Process Communication 是指进程间通信。Android的一个app是运行在一个进程上的（除非你启动了另外一个进程），每一个进程都是运行在一个JVM上的，所以进程和进程之间的内存空间不共享，那么如何完成进程间的通信就非常重要了。&lt;/p&gt;

&lt;p&gt;##Android IPC的几种通信方式
实现进程间的通信的思路大致就是将各个进程理解为2个不可直接交互的系统（比如 客户端 和 服务端必须通过网络来交互），要实现2个系统的数据交换无非2种方式：&lt;br /&gt;
1.系统和系统之间建立消息系统，通过将需要对方知道的消息发送过去进行处理返回，Android提供了Binder来实现进程间的通信，Binder会将一个数据从一个进程clone到另外一个进程（实际上是二进制流的传送，实际上你在不同进程拿到的对象并不是同一个)，像Messenger AIDL 和 ContentProvider实现进程交互，底层都是使用的Binder机制。除了Binder机制外我们还可以像客户端和服务端交互那样，使用socket来完成通信。&lt;/p&gt;

&lt;p&gt;2.系统共享资源，例如共同存储维护一个文件系统， 数据库等等，需要特殊说明，虽然SharePreference是使用的文件读写xml来存储数据的，但是在多进程中操作SharePreference是有问题的，因为SharePreference为了提高性能添加了内存缓存，但是进程间的内存空间是不共享的，所以会造成数据丢失的情况。&lt;/p&gt;

&lt;p&gt;在后面的文章中，作者将陆续为大家介绍使用不同的方式来实现IPC。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">摘要： 1.什么是IPC 2.android实现IPC的几种方式 ##IPC IPC全称Inter-Process Communication 是指进程间通信。Android的一个app是运行在一个进程上的（除非你启动了另外一个进程），每一个进程都是运行在一个JVM上的，所以进程和进程之间的内存空间不共享，那么如何完成进程间的通信就非常重要了。 ##Android IPC的几种通信方式 实现进程间的通信的思路大致就是将各个进程理解为2个不可直接交互的系统（比如 客户端 和 服务端必须通过网络来交互），要实现2个系统的数据交换无非2种方式： 1.系统和系统之间建立消息系统，通过将需要对方知道的消息发送过去进行处理返回，Android提供了Binder来实现进程间的通信，Binder会将一个数据从一个进程clone到另外一个进程（实际上是二进制流的传送，实际上你在不同进程拿到的对象并不是同一个)，像Messenger AIDL 和 ContentProvider实现进程交互，底层都是使用的Binder机制。除了Binder机制外我们还可以像客户端和服务端交互那样，使用socket来完成通信。 2.系统共享资源，例如共同存储维护一个文件系统， 数据库等等，需要特殊说明，虽然SharePreference是使用的文件读写xml来存储数据的，但是在多进程中操作SharePreference是有问题的，因为SharePreference为了提高性能添加了内存缓存，但是进程间的内存空间是不共享的，所以会造成数据丢失的情况。 在后面的文章中，作者将陆续为大家介绍使用不同的方式来实现IPC。</summary></entry><entry><title type="html">Android Gradle上传Maven仓库</title><link href="http://localhost:4000/2017/04/26/gradle-maven/" rel="alternate" type="text/html" title="Android Gradle上传Maven仓库" /><published>2017-04-26T00:00:00+00:00</published><updated>2017-04-26T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/26/gradle-maven</id><content type="html" xml:base="http://localhost:4000/2017/04/26/gradle-maven/">&lt;p&gt;在Android的gradle配置上追加上传Maven的相关操作&lt;/p&gt;

&lt;h2 id=&quot;maven的gradle插件&quot;&gt;maven的gradle插件&lt;/h2&gt;
&lt;p&gt;Android里内置了maven插件 只需要apply plugin: “maven” 即可使用maven插件&lt;/p&gt;

&lt;h2 id=&quot;配置maven&quot;&gt;配置maven&lt;/h2&gt;
&lt;h3 id=&quot;配置maven仓库地址&quot;&gt;配置maven仓库地址&lt;/h3&gt;
&lt;p&gt;在root 下的build.gradle 的subprojects下的repositories中追加一下maven仓库地址，表示给子项目添加仓库地址&lt;/p&gt;
&lt;pre&gt;
  maven {
            url &quot;http://maven.release.test&quot; 
        }
  maven {
            url &quot;http://maven.test&quot;
        }
&lt;/pre&gt;
&lt;h3 id=&quot;统一配置maven的账号信息&quot;&gt;统一配置maven的账号信息&lt;/h3&gt;
&lt;p&gt;我们现在setting.gradle中统一配置账号信息，留待下面使用&lt;/p&gt;

&lt;pre&gt;
gradle.ext {
    // maven config
    mavenUrl = &quot;http://maven.test.release&quot;
    mavenDevUrl = &quot;http://maven.test.snapshot&quot;
    mavenUserName = &quot;deployer&quot;
    mavenPwd = &quot;test&quot;
}
&lt;/pre&gt;
&lt;p&gt;其中：&lt;br /&gt;
mavenUrl表示正式仓库地址&lt;br /&gt;
mavenDevUrl表示snapshot的仓库（这里我们分了2个仓库 你也可以使用一个）&lt;br /&gt;
mavenUserName maven账号的用户名&lt;br /&gt;
mavenPwd macen账号密码&lt;/p&gt;

&lt;h3 id=&quot;配置maven上传&quot;&gt;配置maven上传&lt;/h3&gt;
&lt;p&gt;这里用到的gradle.mavenUrl等 都是刚才在setting.gradle中配置好的&lt;/p&gt;
&lt;pre&gt;
uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            project.afterEvaluate {
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                //修改pom文件（maven的配置文件）
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;  
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;然后我们调用gradle 的uploadArchives 的task就可以了，之后可以在你的maven仓库中查看代码。在这里我们的artifactid直接使用了当前项目的名称，version使用了当前项目android中配置的版本号，你也可以手动设置不过不建议。 &lt;br /&gt;
我们可以直接在build中调用 compile “com.fsilence:{$project.name}:{$version}”来应用了 例如 compile “com.fsilence:test:1.0.0”&lt;/p&gt;

&lt;h2 id=&quot;配置snapshot-和-sources版本&quot;&gt;配置SNAPSHOT 和 sources版本&lt;/h2&gt;
&lt;p&gt;我们在其它的开源软件上经常能看到snapshot版本 和 带源码的版本，那么我们要怎么配置呢？ 我们先来看snapshot版本的配置, snapshot和release的区分主要是在版本号的结尾 如果版本号是以SNAPSHOT结尾的就会本认为是快照版本(其实合理可以用其它的字符串只要和仓库的开头能匹配上即可)，我们可以给snapshot版本配置特殊的仓库:&lt;/p&gt;
&lt;pre&gt;
   snapshotRepository(url: gradle.mavenDevUrl) {
          authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
       }
&lt;/pre&gt;
&lt;p&gt;为了标识打包的是snapshot还是其它版本，我会在项目下的gradle.properties文件中定义个isSnapshot的变量如下:&lt;/p&gt;
&lt;pre&gt;
isSnapshot = true
&lt;/pre&gt;
&lt;p&gt;然后我们就可以在项目中通过project.isSnapshot来划分版本了，然后我们将上面的配置代码加入snapshot版本的控制，&lt;/p&gt;
&lt;pre&gt;
uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            project.afterEvaluate {
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                if (project.isSnapshot) {
                    version = &quot;$versionName-SNAPSHOT&quot;
                }
                //修改pom文件（maven的配置文件）
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;  
            }
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后我们再追加一个sources的版本控制，我们在每个版本都添加一个-sources的版本（包含源码的），首先我们得有一个打包源码的task：&lt;/p&gt;
&lt;pre&gt;
task generateSourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier 'sources'
}
&lt;/pre&gt;
&lt;p&gt;然后我们再次修改上面的配置，也就是我们最终的配置：&lt;/p&gt;
&lt;pre&gt;

uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            snapshotRepository(url: gradle.mavenDevUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            addFilter(&quot;aar-src&quot;){artifact, file -&amp;gt;
                artifact.name == 'aar-src' || artifact.name == 'aar'
            }
            addFilter(&quot;aar&quot;){artifact, file -&amp;gt;
                artifact.name == 'aar'
            }
            project.afterEvaluate {
                print project.isSnapshot
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                def aarSrcVersion = &quot;$versionName-sources&quot;;
                if (project.isSnapshot) {
                    version = &quot;$versionName-SNAPSHOT&quot;
                    aarSrcVersion += &quot;-SNAPSHOT&quot;
                }
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;
                pom('aar-src').artifactId = &quot;$project.name&quot;
                pom('aar-src').groupId = &quot;com.fsilence&quot;
                pom('aar-src').version = aarSrcVersion
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;我们现在达到了这个效果：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们可以手动通过配置 isSnapshot来决定打包的是SnapSHot还是正式版本&lt;/li&gt;
  &lt;li&gt;每个版本都有一个-sources的包是包含项目源码的&lt;br /&gt;
举个例子我们的版本号可以是: 1.0.0 1.0.0-sources 1.0.0-SNAPSHOT 或者 1.0.0-sources-SNAPSHOT是不是很清晰。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解决gradle上使用maven版本不同步的问题&quot;&gt;解决gradle上使用maven版本不同步的问题&lt;/h2&gt;
&lt;p&gt;你以为这样就ok了吗,在实际中我还遇到一个问题，当你在开发发布snap版本的时候，其它引用的地方总是不能及时更新，这是为什么呢？最后我发现是因为gradle对jar包的缓存问题，我们可以才用户目录的.android下的caches/modules-2/files中查找到缓存的文件，这给实际开发造成了很大影响，解决方案有2个：&lt;br /&gt;
1.每次发的版本号都不相同，我们可以在版本号中间再插入一个git的版本号（或者你使用的是svn），git获取版本号的代码如下:&lt;/p&gt;
&lt;pre&gt;
def gitVersion = 'git rev-parse --short HEAD'.execute().text.trim()
&lt;/pre&gt;
&lt;p&gt;这样可以解决我们的问题但是有一个麻烦支出在于 ，引用包的地方必须知道你的git版本号，这可是很麻烦的，如果你又不希望对方知道你的git地址。所以这种方式个人不推荐&lt;br /&gt;
2.让gradle每次都能去下载最新版本的maven仓库,我们有一个dsl的配置如下:&lt;/p&gt;
&lt;pre&gt;
configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}
&lt;/pre&gt;
&lt;p&gt;然后在引用的地方我们改为：&lt;/p&gt;
&lt;pre&gt;
compile (&quot;com.fsilence:test:1.0.0-SNAPSHOT&quot;){changing = true}
&lt;/pre&gt;
&lt;p&gt;这样我们每次调用的时候都会更新到最新版本，如果改成正式版本后曲调后面的changing配置即可。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">在Android的gradle配置上追加上传Maven的相关操作</summary></entry><entry><title type="html">Spock资料汇总</title><link href="http://localhost:4000/2017/04/21/spock-docs/" rel="alternate" type="text/html" title="Spock资料汇总" /><published>2017-04-21T00:00:00+00:00</published><updated>2017-04-21T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/21/spock-docs</id><content type="html" xml:base="http://localhost:4000/2017/04/21/spock-docs/">&lt;p&gt;Spock单元测试资料汇总&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1439793373083.html&quot;&gt;使用Spock框架进行单元测试&lt;/a&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">Spock单元测试资料汇总</summary></entry></feed>