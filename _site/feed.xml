<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-05-12T06:40:03+00:00</updated><id>http://localhost:4000/</id><title type="html">FSilence’s Blog</title><subtitle>FSilence的个人博客</subtitle><author><name>FSilence</name></author><entry><title type="html">ReactNative调研报告</title><link href="http://localhost:4000/2017/05/11/react-native-report/" rel="alternate" type="text/html" title="ReactNative调研报告" /><published>2017-05-11T00:00:00+00:00</published><updated>2017-05-11T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/11/react-native-report</id><content type="html" xml:base="http://localhost:4000/2017/05/11/react-native-report/">&lt;p&gt;2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。&lt;/p&gt;

&lt;h2 id=&quot;reactnative简介&quot;&gt;ReactNative简介&lt;/h2&gt;
&lt;p&gt;在reactnative中文网上有以下简介:&lt;/p&gt;
&lt;pre&gt;
React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。  
React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)  
Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。
&lt;/pre&gt;
&lt;p&gt;React Native是使用javascript和react来实现跨平台开发的, React Native提倡组件化开发: 即提供一个个封装好的组件，组件相互嵌套形成新的组件.你可以完全将App使用ReactNative编写，也可以使用原生和react native混合和的方式。由于目前React Native才发布到0.44版本，还没有发布正式的1.0, 其变动相对比较频繁，在react native升级后经常导致项目不能运行，你必须去做额外的工作来保证项目正常的运行。不过最近React Native的发布已经慢慢趋于稳定了，现在基本是1-2个月发一次版本更新，更新内容也没有之前变化那么大了。&lt;/p&gt;

&lt;p&gt;众所周知Android的碎片化和厂商的定制化是影响app稳定的很重要的原因之一,尤其是在国内，各个手机厂商都对Android系统进行了深度定制。这样的问题在ReactNative上也有很明显的体现，ReactNative在兼容Android各个系统版本和厂商版本的时候会暴露出不少的问题，目前React Native只支持Android 4.1以上，IOS 7.0以上的版本.附上最新的Android版本分布，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25737474&quot;&gt;Android3月份分版本分布&lt;/a&gt;可以看到Android 4.0的应用占比基本在%1左右，所以影响不大。&lt;/p&gt;

&lt;p&gt;在2017年3月爆发了一股苹果商店禁止热更新的事件，很多人都担心苹果是否会封掉Reactnative，其实苹果想要禁止的是热更新的功能。在苹果的拒绝邮件上也只是说明拒绝热更新的能力。从目前来看，这2个月苹果ReactNative依然可以过审。在各个论坛上也并未发现此次禁止热更新对ReactNative有较为明显的影响。&lt;/p&gt;

&lt;h2 id=&quot;reactnative-vs-原生-vs-hybrid&quot;&gt;ReactNative VS 原生 VS Hybrid&lt;/h2&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;(hybrid和 phoneGap APICloud AppCan等思想相同)
hybrid是一款h5的跨终端的解决方案，思想是 编写一次，就可以跨平台。
本质上hybrid还是web界面，只不过针对各个平台提供了一些调用native方法的api，通过js 和 native交互进行通信。&lt;br /&gt;
用web渲染界面是比较耗时的，为了解决界面的渲染耗时，react-native将界面用原生实现，而js部分只负责描述界面并将描述后的界面通过js和native的交互机制通知给终端，让终端根据js传递过来的界面描述信息来选择本地的控件进行界面的拼装。react-native的思想是 学习一次，可以跨平台开发（仍需要各个终端的人配合）。&lt;/p&gt;

&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;原生 &amp;gt; ReactNative &amp;gt; Hybrid&lt;br /&gt;
具体的性能对比参数可以查看&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发维护&quot;&gt;开发&amp;amp;维护&lt;/h3&gt;
&lt;p&gt;以下成本和更新能力模块参考了&lt;a href=&quot;http://blog.csdn.net/yczz/article/details/50468181&quot;&gt;H5、React Native、Native应用对比分析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;维护成本&quot;&gt;维护成本&lt;/h3&gt;
&lt;p&gt;Hybrid &amp;lt; ReactNative &amp;lt; 原生&lt;br /&gt;
Hybrid是H5的夸平台解决方案，ReactNative可以达到百分之90左右的代码共用，但仍需要终端支持。&lt;/p&gt;

&lt;p&gt;H5/Hybird： Web代码 ＋ iOS/Android平台支持&lt;/p&gt;

&lt;p&gt;React Native：可以一个开发团队 ＋ iOS/Android工程师；业务组件颗粒度小，不用把握全局即可修改业务代码。&lt;/p&gt;

&lt;p&gt;Native：iOS/Android开发周期长，两个开发团队。&lt;/p&gt;

&lt;p&gt;总结：React Native 统一了开发人员技术栈，代码维护相对容易。&lt;/p&gt;
&lt;h4 id=&quot;更新能力&quot;&gt;更新能力&lt;/h4&gt;
&lt;p&gt;H5/Hybird： 随时更新，适合做营销页面，目前携程一些BU全部都是H5页面；但是重要的部分还是Native。&lt;/p&gt;

&lt;p&gt;React Native：React Native部分可以热更新，bug及时修复。&lt;/p&gt;

&lt;p&gt;Native：随版本更新，尤其iOS审核严格，需要测试过关，否则影响用户。&lt;/p&gt;

&lt;h2 id=&quot;react-canvas&quot;&gt;React-Canvas&lt;/h2&gt;
&lt;p&gt;为了解决webapp渲染dom的效率问题，Flipboard推出了一款react-canvas，它的思想是用做游戏的方式来做app。界面渲染针对到canvas上，通过重新定义绘制过程来减少web界面渲染时候的开销问题。&lt;br /&gt;
react-canvas 也是使用的css-layout和react-native一致，也集成了react，只是最终界面是通过canvas展示的。
react-canvas因为是针对webapp的，所以它的灵活性要比react-native强，渲染的卡顿问题比较接近原生,由于react-canvas还是一个webapp所以有一些原生的界面效果不太好处理。react-canvas如果要和native交互需要单独提供本地的基础库和js和native的通信机制。
其实react-native可以理解成重写了一个简版的web浏览器，它只支持一些特殊的定制化界面，用native实现界面渲染来达到原生的体验效果。&lt;/p&gt;

&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;目前国内使用ReactNative的还不是很多（有些小的应用是完全用React Native来实现的）, 比较出名的是 携程的火车票模块， QQ空间，销售易的包中也发现了React Native的痕迹。要想看到更多的国内案例可以通过react native中文网收集的案例上查看: &lt;a href=&quot;http://reactnative.cn/cases.html&quot;&gt;ReactNative案例&lt;/a&gt;。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">2015年9月15日Facebook发布了ReactNative for Android，引发了学习使用ReactNative开发跨平台引用的热潮。目前React Native发布到了0.44的版本。最近项目中考虑是否要接入ReactNative, 所以对ReactNative进行了一些调研性的工作。</summary></entry><entry><title type="html">用gradle构建java项目</title><link href="http://localhost:4000/2017/05/03/gradle-server-project/" rel="alternate" type="text/html" title="用gradle构建java项目" /><published>2017-05-03T00:00:00+00:00</published><updated>2017-05-03T00:00:00+00:00</updated><id>http://localhost:4000/2017/05/03/gradle-server-project</id><content type="html" xml:base="http://localhost:4000/2017/05/03/gradle-server-project/">&lt;p&gt;一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置&lt;/p&gt;

&lt;p&gt;IDE: idea&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先安装gradle 并配置环境变量&lt;/li&gt;
  &lt;li&gt;在项目目录下执行 gradle wrapper 生成wrapper文件（之后再idea中配置使用wrapper构建，使用wrapper的好处在于使用项目配置的gradle版本 不会因为版本冲突引发问题)可以通过–verison 来制定特定的版本&lt;/li&gt;
  &lt;li&gt;在idea 设置中搜索gradle 选择使用gradle wrapper 并勾选use-auto-import然后即可&lt;/li&gt;
  &lt;li&gt;根据需求自己定义setting.gradle 和 build.gradle中的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在新建完项目执行单元测试的时候你可能会遇到Error:gradle-resources-test:di_test: java.lang.NoClassDefFoundError: org/apache/tools/ant/util/ReaderInputStream 的错误这是你可以执行以下操作：&lt;br /&gt;
File → Invalidate Caches / Restart 然后重启idea即可&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">一般像后台的项目都是用maven构建的，我们来看一下使用gradle来构建java项目，本文不涉及到具体的gradle配置</summary></entry><entry><title type="html">Android Gradle上传Maven仓库</title><link href="http://localhost:4000/2017/04/26/gradle-maven/" rel="alternate" type="text/html" title="Android Gradle上传Maven仓库" /><published>2017-04-26T00:00:00+00:00</published><updated>2017-04-26T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/26/gradle-maven</id><content type="html" xml:base="http://localhost:4000/2017/04/26/gradle-maven/">&lt;p&gt;在Android的gradle配置上追加上传Maven的相关操作&lt;/p&gt;

&lt;h2 id=&quot;maven的gradle插件&quot;&gt;maven的gradle插件&lt;/h2&gt;
&lt;p&gt;Android里内置了maven插件 只需要apply plugin: “maven” 即可使用maven插件&lt;/p&gt;

&lt;h2 id=&quot;配置maven&quot;&gt;配置maven&lt;/h2&gt;
&lt;h3 id=&quot;配置maven仓库地址&quot;&gt;配置maven仓库地址&lt;/h3&gt;
&lt;p&gt;在root 下的build.gradle 的subprojects下的repositories中追加一下maven仓库地址，表示给子项目添加仓库地址&lt;/p&gt;
&lt;pre&gt;
  maven {
            url &quot;http://maven.release.test&quot; 
        }
  maven {
            url &quot;http://maven.test&quot;
        }
&lt;/pre&gt;
&lt;h3 id=&quot;统一配置maven的账号信息&quot;&gt;统一配置maven的账号信息&lt;/h3&gt;
&lt;p&gt;我们现在setting.gradle中统一配置账号信息，留待下面使用&lt;/p&gt;

&lt;pre&gt;
gradle.ext {
    // maven config
    mavenUrl = &quot;http://maven.test.release&quot;
    mavenDevUrl = &quot;http://maven.test.snapshot&quot;
    mavenUserName = &quot;deployer&quot;
    mavenPwd = &quot;test&quot;
}
&lt;/pre&gt;
&lt;p&gt;其中：&lt;br /&gt;
mavenUrl表示正式仓库地址&lt;br /&gt;
mavenDevUrl表示snapshot的仓库（这里我们分了2个仓库 你也可以使用一个）&lt;br /&gt;
mavenUserName maven账号的用户名&lt;br /&gt;
mavenPwd macen账号密码&lt;/p&gt;

&lt;h3 id=&quot;配置maven上传&quot;&gt;配置maven上传&lt;/h3&gt;
&lt;p&gt;这里用到的gradle.mavenUrl等 都是刚才在setting.gradle中配置好的&lt;/p&gt;
&lt;pre&gt;
uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            project.afterEvaluate {
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                //修改pom文件（maven的配置文件）
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;  
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;然后我们调用gradle 的uploadArchives 的task就可以了，之后可以在你的maven仓库中查看代码。在这里我们的artifactid直接使用了当前项目的名称，version使用了当前项目android中配置的版本号，你也可以手动设置不过不建议。 &lt;br /&gt;
我们可以直接在build中调用 compile “com.fsilence:{$project.name}:{$version}”来应用了 例如 compile “com.fsilence:test:1.0.0”&lt;/p&gt;

&lt;h2 id=&quot;配置snapshot-和-sources版本&quot;&gt;配置SNAPSHOT 和 sources版本&lt;/h2&gt;
&lt;p&gt;我们在其它的开源软件上经常能看到snapshot版本 和 带源码的版本，那么我们要怎么配置呢？ 我们先来看snapshot版本的配置, snapshot和release的区分主要是在版本号的结尾 如果版本号是以SNAPSHOT结尾的就会本认为是快照版本(其实合理可以用其它的字符串只要和仓库的开头能匹配上即可)，我们可以给snapshot版本配置特殊的仓库:&lt;/p&gt;
&lt;pre&gt;
   snapshotRepository(url: gradle.mavenDevUrl) {
          authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
       }
&lt;/pre&gt;
&lt;p&gt;为了标识打包的是snapshot还是其它版本，我会在项目下的gradle.properties文件中定义个isSnapshot的变量如下:&lt;/p&gt;
&lt;pre&gt;
isSnapshot = true
&lt;/pre&gt;
&lt;p&gt;然后我们就可以在项目中通过project.isSnapshot来划分版本了，然后我们将上面的配置代码加入snapshot版本的控制，&lt;/p&gt;
&lt;pre&gt;
uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            project.afterEvaluate {
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                if (project.isSnapshot) {
                    version = &quot;$versionName-SNAPSHOT&quot;
                }
                //修改pom文件（maven的配置文件）
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;  
            }
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后我们再追加一个sources的版本控制，我们在每个版本都添加一个-sources的版本（包含源码的），首先我们得有一个打包源码的task：&lt;/p&gt;
&lt;pre&gt;
task generateSourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier 'sources'
}
&lt;/pre&gt;
&lt;p&gt;然后我们再次修改上面的配置，也就是我们最终的配置：&lt;/p&gt;
&lt;pre&gt;

uploadArchives{
    repositories {
        mavenDeployer {
            repository(url: gradle.mavenUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            snapshotRepository(url: gradle.mavenDevUrl) {
                authentication(userName: gradle.mavenUserName, password: gradle.mavenPwd)
            }
            addFilter(&quot;aar-src&quot;){artifact, file -&amp;gt;
                artifact.name == 'aar-src' || artifact.name == 'aar'
            }
            addFilter(&quot;aar&quot;){artifact, file -&amp;gt;
                artifact.name == 'aar'
            }
            project.afterEvaluate {
                print project.isSnapshot
                def versionName = &quot;${android.defaultConfig.versionName}&quot;
                def version = versionName;
                def aarSrcVersion = &quot;$versionName-sources&quot;;
                if (project.isSnapshot) {
                    version = &quot;$versionName-SNAPSHOT&quot;
                    aarSrcVersion += &quot;-SNAPSHOT&quot;
                }
                pom('aar').version = version;
                pom('aar').artifactId = &quot;$project.name&quot;
                pom('aar').groupId = &quot;com.fsilence&quot;
                pom('aar-src').artifactId = &quot;$project.name&quot;
                pom('aar-src').groupId = &quot;com.fsilence&quot;
                pom('aar-src').version = aarSrcVersion
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;我们现在达到了这个效果：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们可以手动通过配置 isSnapshot来决定打包的是SnapSHot还是正式版本&lt;/li&gt;
  &lt;li&gt;每个版本都有一个-sources的包是包含项目源码的&lt;br /&gt;
举个例子我们的版本号可以是: 1.0.0 1.0.0-sources 1.0.0-SNAPSHOT 或者 1.0.0-sources-SNAPSHOT是不是很清晰。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解决gradle上使用maven版本不同步的问题&quot;&gt;解决gradle上使用maven版本不同步的问题&lt;/h2&gt;
&lt;p&gt;你以为这样就ok了吗,在实际中我还遇到一个问题，当你在开发发布snap版本的时候，其它引用的地方总是不能及时更新，这是为什么呢？最后我发现是因为gradle对jar包的缓存问题，我们可以才用户目录的.android下的caches/modules-2/files中查找到缓存的文件，这给实际开发造成了很大影响，解决方案有2个：&lt;br /&gt;
1.每次发的版本号都不相同，我们可以在版本号中间再插入一个git的版本号（或者你使用的是svn），git获取版本号的代码如下:&lt;/p&gt;
&lt;pre&gt;
def gitVersion = 'git rev-parse --short HEAD'.execute().text.trim()
&lt;/pre&gt;
&lt;p&gt;这样可以解决我们的问题但是有一个麻烦支出在于 ，引用包的地方必须知道你的git版本号，这可是很麻烦的，如果你又不希望对方知道你的git地址。所以这种方式个人不推荐&lt;br /&gt;
2.让gradle每次都能去下载最新版本的maven仓库,我们有一个dsl的配置如下:&lt;/p&gt;
&lt;pre&gt;
configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}
&lt;/pre&gt;
&lt;p&gt;然后在引用的地方我们改为：&lt;/p&gt;
&lt;pre&gt;
compile (&quot;com.fsilence:test:1.0.0-SNAPSHOT&quot;){changing = true}
&lt;/pre&gt;
&lt;p&gt;这样我们每次调用的时候都会更新到最新版本，如果改成正式版本后曲调后面的changing配置即可。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">在Android的gradle配置上追加上传Maven的相关操作</summary></entry><entry><title type="html">Spock资料汇总</title><link href="http://localhost:4000/2017/04/21/spock-docs/" rel="alternate" type="text/html" title="Spock资料汇总" /><published>2017-04-21T00:00:00+00:00</published><updated>2017-04-21T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/21/spock-docs</id><content type="html" xml:base="http://localhost:4000/2017/04/21/spock-docs/">&lt;p&gt;Spock单元测试资料汇总&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1439793373083.html&quot;&gt;使用Spock框架进行单元测试&lt;/a&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">Spock单元测试资料汇总</summary></entry><entry><title type="html">git分支恢复</title><link href="http://localhost:4000/2017/04/13/git-recover-branch/" rel="alternate" type="text/html" title="git分支恢复" /><published>2017-04-13T00:00:00+00:00</published><updated>2017-04-13T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/13/git-recover-branch</id><content type="html" xml:base="http://localhost:4000/2017/04/13/git-recover-branch/">&lt;p&gt;今天误删了git分支，还好可以恢复&lt;/p&gt;

&lt;p&gt;今天git push之后 以为merge了 就把本地和远程分支都删掉了，然后悲催的发现并没有执行merge操作。。还好分支可以恢复。。&lt;/p&gt;

&lt;p&gt;这个时候我们可以从之前提交的那次merge request中查找到提交的版本号，然后本地执行&lt;/p&gt;
&lt;pre&gt;
 git branch 分支名称 commit号
&lt;/pre&gt;
&lt;p&gt;然后重新push即可。。。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">今天误删了git分支，还好可以恢复</summary></entry><entry><title type="html">gradle调试断点</title><link href="http://localhost:4000/2017/04/11/gradle-debug/" rel="alternate" type="text/html" title="gradle调试断点" /><published>2017-04-11T00:00:00+00:00</published><updated>2017-04-11T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/11/gradle-debug</id><content type="html" xml:base="http://localhost:4000/2017/04/11/gradle-debug/">&lt;p&gt;调试断点我们的gradle插件&lt;/p&gt;

&lt;p&gt;我们免不了需要调试gradle脚本。但是要特殊说明的是， 现在还没有办法调试gradle的脚本文件， 我们只能通过pringln 来输出message， 然后在Gradle Console中查看。&lt;br /&gt;
我们这里要说的是利用远程调试，去断点调试自己编写的gradle插件。其实gradle的脚本使用groovy编写的而groovy也是运行在jvm上的，所以这里的调试方法就是远程调试jvm的方法，此方法同样适用于调试编译时注解（编译时注解 要注意clean项目）。&lt;/p&gt;

&lt;h2 id=&quot;配置remote&quot;&gt;配置remote&lt;/h2&gt;
&lt;p&gt;首先我们先点击Edit Config 点击+号选择remote: &lt;br /&gt;
&lt;img src=&quot;/images/gradle-debug1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后复制下面代码，将suspend=n改为suspend=y，表示一直阻塞等待:&lt;br /&gt;
&lt;img src=&quot;/images/gradle-debug2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你也可以修改name为你喜欢的名字，然后点击ok。&lt;/p&gt;

&lt;h2 id=&quot;配置运行时候的参数&quot;&gt;配置运行时候的参数&lt;/h2&gt;
&lt;p&gt;然后我们有几种方法来运行我们的gradle命令，，&lt;/p&gt;

&lt;h3 id=&quot;方法一&quot;&gt;方法一&lt;/h3&gt;
&lt;p&gt;我们可以在命令行执行:&lt;/p&gt;
&lt;pre&gt;
 export GRADLE_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot;
 &lt;/pre&gt;
&lt;p&gt;然后直接运行你的gradle命令，你会方法会一直等待5005的端口，知识后依旧可以debug运行刚才的remote，进行断点调试了。&lt;br /&gt;
 你可以通过 unset GRADLE_OPTS 来取消这个配置&lt;/p&gt;

&lt;h3 id=&quot;方法二&quot;&gt;方法二&lt;/h3&gt;
&lt;p&gt;在gradle中找到你要断点的命令，点击create config:&lt;br /&gt;
 &lt;img src=&quot;/images/gradle-debug3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在VM options中输入你刚才复制并修改的参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gradle-debug4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击运行，效果同上 会等待设置的5005端口，然后再切到remote 执行debug即可。&lt;/p&gt;

&lt;h3 id=&quot;方法三&quot;&gt;方法三&lt;/h3&gt;

&lt;p&gt;直接在gradle.properties中设置jvm参数（刚才复制的内容）:&lt;/p&gt;

&lt;pre&gt;
  org.gradle.jvmargs=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005
  &lt;/pre&gt;</content><author><name>FSilence</name></author><summary type="html">调试断点我们的gradle插件</summary></entry><entry><title type="html">《乖，摸摸头》读后感</title><link href="http://localhost:4000/2017/04/11/dabin-book/" rel="alternate" type="text/html" title="《乖，摸摸头》读后感" /><published>2017-04-11T00:00:00+00:00</published><updated>2017-04-11T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/11/dabin-book</id><content type="html" xml:base="http://localhost:4000/2017/04/11/dabin-book/">&lt;p&gt;之前听朋友推荐过大冰的书，最近在地铁上拜读了一下其中的一本《乖，摸摸头》，其实我很久没看过非专业的书籍了，看完后还是有很多感慨的，想要在这里发发牢骚。&lt;/p&gt;

&lt;p&gt;大冰系列的读物基本上是在描述在作者的生涯中所经历的各种人各种事，用作者身边的个性鲜明的人和故事来向我们展示一个不一样的世界。其实大冰的故事何尝不是在这个金钱至上的社会的一股清流，何尝不是对现在充满钱味的社会的一次度化。&lt;/p&gt;

&lt;h2 id=&quot;关于幸福&quot;&gt;关于幸福&lt;/h2&gt;
&lt;p&gt;大冰的周围充斥着各种个性鲜明的人，在我看来大冰将的故事中的主人公都有一个鲜明的特征，那就是他们自己是感觉到幸福的。他们很多人并不富裕，可能不满足现在社会上对成功人士，对幸福的定义，但是他们的确是幸福的。他们的心是幸福的。&lt;/p&gt;

&lt;p&gt;听完这些故事，我的感触就是我们每个认都有属于自己的幸福，我们应该好好想想我们自己想要的到底是什么，追求的又是个什么，不能在时间洪流中一步步盲目的前行。&lt;/p&gt;

&lt;p&gt;我想说的并不是我们都应该向书中的主人公那样去四处旅游，去做流浪歌手等等。。我们有自己对幸福的定义。并不是说我们都要视金钱如粪土等等。我们应该去追寻我们的
内心，保留心中的纯净。&lt;/p&gt;

&lt;p&gt;还记得以前在校的时候我也说过大话，说我虽然改变不了世界，但是世界也别想改变我。但是现实狠狠的打了我的脸，在步入社会后，这个世界确实在潜移默化的改变了我们。回收想想在学校的那个我们，现在我们也不得不去考虑房子，票子等等。。。&lt;/p&gt;

&lt;h2 id=&quot;关于和平&quot;&gt;关于和平&lt;/h2&gt;
&lt;p&gt;书中介绍了一个老兵的故事，，老兵参加过越南战争。老兵的部队最后活着的没有几个，其他都牺牲了。 真正能感受到战争的残酷，我们应该珍惜和平，我们现在的生活其实挺好的。&lt;/p&gt;

&lt;h2 id=&quot;关于自身&quot;&gt;关于自身&lt;/h2&gt;
&lt;p&gt;我觉得最大的收获就是又一次督促我能够追求自己想要的生活。为自己想过的生活加油吧。。。&lt;/p&gt;

&lt;p&gt;说了很多碎碎念，，别介意，书真的不错，可以一看，你就当看故事了，听听故事收获一份属于你的感动。&lt;/p&gt;

&lt;p&gt;现在我开始接着看大冰的其它书了，期待其它的感动。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">之前听朋友推荐过大冰的书，最近在地铁上拜读了一下其中的一本《乖，摸摸头》，其实我很久没看过非专业的书籍了，看完后还是有很多感慨的，想要在这里发发牢骚。</summary></entry><entry><title type="html">gradle在不同系统下适配</title><link href="http://localhost:4000/2017/04/10/gradlew-env-get/" rel="alternate" type="text/html" title="gradle在不同系统下适配" /><published>2017-04-10T00:00:00+00:00</published><updated>2017-04-10T00:00:00+00:00</updated><id>http://localhost:4000/2017/04/10/gradlew-env-get</id><content type="html" xml:base="http://localhost:4000/2017/04/10/gradlew-env-get/">&lt;p&gt;有时我们需要自己定制一些gradle的执行task，可能会用到一些系统中的其它环境，这时需要我们针对不同的OS做一些适配。&lt;/p&gt;

&lt;p&gt;##判断当前系统环境
方法一：&lt;br /&gt;
获取os的name判断其中是否包含windows字段&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
def isWindows() {
    return System.properties['os.name'].contains('windows');
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;方法二： 
通过OperatingSystem类中的方法来判断当前环境&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
def isWindows() {
 return org.gradle.internal.os.OperatingSystem.current().isWindows()
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;##获取系统环境变量&lt;br /&gt;
在windows环境下可以通过  $System.env来获取 比如获取ANDROID_HOME 可以调用$System.env.ANDROID_HOME（注意在path下配置ANDROID_HOME变量）&lt;/p&gt;

&lt;p&gt;在linux和mac上可以通过which指令来获取环境变量，比如我要获取adb的环境变量可以通过以下代码获取：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
&quot;which adb&quot;.execute().inputStream.readLines()[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mark：&lt;br /&gt;
TODO此方法可以在命令行中调用gradlew命令的时候获取到adb的环境变量，但是如果在Android Studio上直接运行时获取不到的，暂时不知道为什么先mark以下&lt;/p&gt;

&lt;p&gt;最近发现其实我们不必滴啊用which adb ，我门可以配置统一的ANDROID_HOME来解决，以前是不知道mac 怎么配置ANDROID_HOME，其实mac配置系统变量也很简单 只需要调用 export命令即可，我们可以修改~/.bash_profile 添加export ANROID_HOME=”“即可。&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">有时我们需要自己定制一些gradle的执行task，可能会用到一些系统中的其它环境，这时需要我们针对不同的OS做一些适配。</summary></entry><entry><title type="html">用GithubPages搭建个人Blog</title><link href="http://localhost:4000/2017/03/29/github-pages-jekyll/" rel="alternate" type="text/html" title="用GithubPages搭建个人Blog" /><published>2017-03-29T00:00:00+00:00</published><updated>2017-03-29T00:00:00+00:00</updated><id>http://localhost:4000/2017/03/29/github-pages-jekyll</id><content type="html" xml:base="http://localhost:4000/2017/03/29/github-pages-jekyll/">&lt;p&gt;用GithubPages + jekyll搭建你的个人Blog, 专注于内容。&lt;/p&gt;

&lt;pre&gt;
内容大纲：
1.配置githubpages  
2.选择你的jekyll模板    
3.开始写Blog  
&lt;/pre&gt;
&lt;p&gt;以前总是羡慕别人有自己的Blog，一直想有有个属于自己的Blog网站。之前断断续续写过一些，用过csdn 用过 eoe的blog（现在已经没有这个功能了）。 也尝试过wordpress等，买过云服务器。最后总是不了了之。前段时间偶然看到了githubpages, 眼前一亮
，这么nb的功能以前竟然不知道。然后花了几天时间fork了别人的Blog 修改后搭建了自己的Blog。&lt;/p&gt;

&lt;h2 id=&quot;配置githubs&quot;&gt;配置githubs&lt;/h2&gt;
&lt;p&gt;官网上有很详细的介绍，基本就是你新建一个以你的github名字开始+github.io的仓库，具体的配置过程可以移步官网 &lt;a href=&quot;http://github.io&quot;&gt;github.io&lt;/a&gt; 我就不做重复的搬运了 &lt;br /&gt;
之后可以在工程的Settings中做一些配置，比如指定你的个人域名，&lt;/p&gt;

&lt;h2 id=&quot;配置jekyll&quot;&gt;配置jekyll&lt;/h2&gt;
&lt;p&gt;关于jekyll 可以移步 &lt;a href=&quot;https://help.github.com/articles/using-jekyll-as-a-static-site-generator-with-github-pages/&quot;&gt;Using jekyll with GithubPages&lt;/a&gt;&lt;br /&gt;
基本是说jekyll是一个静态html的生成框架。&lt;br /&gt;
关于jekyll的配置模板网上有很多 你可以选择你喜欢的主题加以修改&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyll themes&lt;/a&gt;&lt;br /&gt;
如果你像我一样对前端不了解的话，别着急你可以fork别人的blog 然后修改其中的内容，告诉你个小技巧 你可以在github上搜索github,io 然后选择你喜欢的blog fork后修改其中的关键内容就行，我就是fork的 &lt;a href=&quot;https://github.com/mzlogin/mzlogin.github.io&quot;&gt;https://github.com/mzlogin/mzlogin.github.io&lt;/a&gt;&lt;br /&gt;
一般你只需要修改_config.yml 和CNAME中的东西即可，是不是很容易啊。如果项目中设计到其它第三方的插件，你需要注册你个人的插件并替换相关内容，比如用到的评论模块,你需要换成你个人的。&lt;/p&gt;

&lt;h2 id=&quot;开始blog&quot;&gt;开始Blog&lt;/h2&gt;
&lt;p&gt;将项目push到你新建的github仓库中，之后你就可以开始写Blog了。&lt;/p&gt;

&lt;p&gt;本文只是一个阐述，详细过程可以参照其他人的Blog &lt;a href=&quot;http://www.jianshu.com/p/3f355c7872d5&quot;&gt;http://www.jianshu.com/p/3f355c7872d5&lt;/a&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">用GithubPages + jekyll搭建你的个人Blog, 专注于内容。</summary></entry><entry><title type="html">博客测试</title><link href="http://localhost:4000/2017/03/29/FirstBlogTest/" rel="alternate" type="text/html" title="博客测试" /><published>2017-03-29T00:00:00+00:00</published><updated>2017-03-29T00:00:00+00:00</updated><id>http://localhost:4000/2017/03/29/FirstBlogTest</id><content type="html" xml:base="http://localhost:4000/2017/03/29/FirstBlogTest/">&lt;p&gt;博客第一次测试&lt;/p&gt;

&lt;p&gt;欢迎关注公众号:&lt;br /&gt;
&lt;img src=&quot;/wx_code.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>FSilence</name></author><summary type="html">博客第一次测试</summary></entry></feed>